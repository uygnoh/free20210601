############################################################
### % uCOS-II 工程模板
############################################################
void SysTick_Handler(void)
{
        OSIntEnter();   //进入中断
        OSTimeTick();   //调用uCOS-II的时钟服务程序
        OSIntExit();    //触发任务切换软中断
}


void Delay_Init(void)
{
        uint32_t reload;
      
        //选择外部时钟 HCLK/8
        SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK_Div8);
        //为系统时钟的 1/8
        fac_us = (SystemCoreClock / 8000000);
   
        //每秒计数的次数, 单位为K
        reload = (SystemCoreClock / 8000000);
        //根据OS_TICKS_PER_SEC，设定溢出时间
        reaload *= (1000000 / OS_TICKS_PER_SEC);
        
        //代表uCOS可以延时最小单位 
        fac_ms = (1000 / OS_TICKS_PER_SEC);
        //开启SysTick中断
        SysTick->CTRL |= SysTick_CTRL_TICKINT_Msk;
        //每(1 / OS_TICKS_PER_SCE秒)中断一次
        SysTick->LOAD |= reload;
        //开启SysTick定时器
        SysTick->CTRL |= Systick_CTRL_ENABLE_Msk;        
}


int main(void)
{
        Delay_Init();
        RCC_Configuration();    //设置系统时钟(72MHz)
}



############################################################
### % uCOS-II 任务
############################################################
INT8U  OSTaskCreate (void   (*task)(void *p_arg),
                     void    *p_arg,
                     OS_STK  *ptos,
                     INT8U    prio)
{
    OS_STK     *psp;
    INT8U       err;
    
/* Allocate storage for CPU status register */
//为CPU状态寄存器分配存储
#if OS_CRITICAL_METHOD == 3u   
    OS_CPU_SR   cpu_sr = 0u;
#endif

#ifdef OS_SAFETY_CRITICAL_IEC61508
    if (OSSafetyCriticalStartFlag == OS_TRUE) {
        OS_SAFETY_CRITICAL_EXCEPTION();
        return (OS_ERR_ILLEGAL_CREATE_RUN_TIME);
    }
#endif

#if OS_ARG_CHK_EN > 0u
    /* Make sure priority is within allowable range */
    //确保优先级在允许的范围内
    if (prio > OS_LOWEST_PRIO) {        
        return (OS_ERR_PRIO_INVALID);
    }
#endif


    //关闭中断
    OS_ENTER_CRITICAL();
    /* Make sure we don't create the task from within an ISR */
    //确保我们不会从ISR中创建任务
    if (OSIntNesting > 0u) {             
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
    }
    /* Make sure task doesn't already exist at this priority */
    //确保此优先级的任务不存在
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { 
        /* Reserve the priority to prevent others from doing ... */
        //保留优先权以防止其他人这样做
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;
        
        /* ... the same thing until task is created.  */
        //同样的事情，直到任务被创建
        
        //打开中断
        OS_EXIT_CRITICAL();
        
        
        ///* Initialize the task's stack */
        //初始化任务的堆栈
        psp = OSTaskStkInit(task, p_arg, ptos, 0u);
        err = OS_TCBInit(prio, psp, (OS_STK *)0, 0u, 0u, (void *)0, 0u);
        if (err == OS_ERR_NONE) {
            OS_TRACE_TASK_CREATE(OSTCBPrioTbl[prio]);
            /* Find highest priority task if multitasking has started*/
            //如果已启动多任务处理，则查找优先级最高的任务
            if (OSRunning == OS_TRUE) {      
                OS_Sched();
            }
        } else {
            OS_TRACE_TASK_CREATE_FAILED(OSTCBPrioTbl[prio]);
            OS_ENTER_CRITICAL();
            /* Make this priority available to others */
            //将此优先级提供给其他人
            OSTCBPrioTbl[prio] = (OS_TCB *)0;
            OS_EXIT_CRITICAL();
        }
        return (err);
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
}
#endif

