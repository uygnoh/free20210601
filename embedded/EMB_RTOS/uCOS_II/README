############################################################
### % uCOS-II 
############################################################
assingned               % 分配
resume                  % 恢复
Pending                 % 请求


OSTCBFreeList           % 它指向TCB的_空闲链表(单链表结构)
OSTCBList               % 它指向TCB的_就绪链表(双链表结构)


OSLockNesting           % 调度器锁
OSIntNesting            % 中断嵌套层数
Mutex PIP               % 互斥信号量的进程提升优先级



############################################################
### % uCOS-II 全局变量
############################################################
OS_EXT  INT32U  OSCtxSwCtr;     % Counter of number of context switches
OS_EXT  INT8U   OSIntNesting;   % Interrupt nesting level
OS_EXT  INT8U   OSLockNesting;  % Multitasking lock nesting level


// 当前任务优先级号码， 最高优先级任务的优先级号码
OS_EXT  INT8U   OSPrioCur;      % Priority of current task
OS_EXT  INT8U   OSPrioHighRdy;  % Priority of highest priority task
// (INT8U)任务就绪组， (INT8U)任务就绪表
x = OS_RDY_TBL_SIZE
OS_EXT  OS_PRIO OSRdyGrp;       % Ready list group
OS_EXT  OS_PRIO OSRdyTbl[x];    % Table of tasks which are ready to run


OS_EXT  OS_TCB  *OSTCBCur;      % Pointer to currently running TCB 
OS_EXT  OS_TCB  *OSTCBFreeList; % Pointer to list of free TCBs 
OS_EXT  OS_TCB  *OSTCBHighRdy;  % Pointer to highest priority TCB R-to-R
OS_EXT  OS_TCB  *OSTCBList;     % Pointer to doubly linked list of TCBs 


___________________________________________________________
1 所有的任务控制块TCB都是存放在 任务控制块列表数组OSTCBTbl[] 中，系统
  通过任务控制块优先级表OSTCBPrioTbl[]  查询到任务控制块的地址，任务
  控制块的相关数据定义。
2 任务控制块优先级表OSTCBPrioTbl[]   是以任务为索引，里面保存的是任务
  0到最大任务的任务控制块的首地址，据此可以通过任务优先级号快速找到当前任
  务在任务控制块中的首地址，而不必到任务控制块链表中去一步一步查找，加快了
  任务的切换时间，提高了操作系统的效率。
  ___________________________________________________________
% Table of pointers to created TCBs (任务控制块优先级表)
OS_EXT  OS_TCB  *OSTCBPrioTbl[OS_LOWEST_PRIO + 1u];
% Table of TCBs (任务控制块表)
OS_EXT  OS_TCB   OSTCBTbl[OS_MAX_TASKS + OS_N_SYS_TASKS];   



############################################################
### % uCOS-II 中奇怪的对称代码
############################################################
// 是为了防止长时间的关中断，影响操作系统的实时性
// 任务上锁是为了让别的任务不能获得执行权

//调度器上锁
if (OSLockNesting < 255) {
        OSLockNesting++;
}
OS_EXIT_CRITICAL();     
OS_Dummy();
OS_ENTRY_CRITICAL();
//调度器开锁
if (OSLockNesting > 0) {
        OSLockNesting--;
}
