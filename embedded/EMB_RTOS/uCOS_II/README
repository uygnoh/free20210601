############################################################
### // uCOS-II //
############################################################
assingned                       // 分配
resume                          // 恢复
Pending                         // 请求

OSTCBFreeList                   // 它指向TCB的_空闲链表(单链表结构)
OSTCBList                       // 它指向TCB的_就绪链表(双链表结构)
OSLockNesting                   // 调度器锁
OSIntNesting                    // 中断嵌套层数
Mutex PIP                       // 互斥信号量的进程提升优先级



############################################################
### // uCOS-II 全局变量 //
############################################################
OS_EXT  INT32U  OSCtxSwCtr;     // Counter of number of context switches
OS_EXT  INT8U   OSIntNesting;   // 中断嵌套层数
OS_EXT  INT8U   OSLockNesting;  // Multitasking lock nesting level
OS_EXT  INT8U   OSPrioCur;      // 当前任务的优先级
OS_EXT  INT8U   OSPrioHighRdy;  // 在就绪列表中最高的优先级任务
OS_EXT  OS_PRIO OSRdyGrp;       // 就绪组
OS_EXT  OS_PRIO OSRdyTbl[Y];    // 就绪表
OS_EXT  OS_TCB  *OSTCBCur;      // Pointer to currently running TCB 
OS_EXT  OS_TCB  *OSTCBFreeList; // Pointer to list of free TCBs 
OS_EXT  OS_TCB  *OSTCBHighRdy;  // Pointer to highest priority TCB R-to-R
OS_EXT  OS_TCB  *OSTCBList;     // Pointer to doubly linked list of TCBs 


___________________________________________________________
1 所有的任务控制块TCB都是存放在 任务控制块列表数组OSTCBTbl[] 中，系统
  通过任务控制块优先级表OSTCBPrioTbl[]  查询到任务控制块的地址，任务
  控制块的相关数据定义。
2 任务控制块优先级表OSTCBPrioTbl[]   是以任务为索引，里面保存的是任务
  0到最大任务的任务控制块的首地址，据此可以通过任务优先级号快速找到当前任
  务在任务控制块中的首地址，而不必到任务控制块链表中去一步一步查找，加快了
  任务的切换时间，提高了操作系统的效率.
  ___________________________________________________________
// Table of pointers to created TCBs (任务控制块优先级表)
OS_EXT  OS_TCB  *OSTCBPrioTbl[OS_LOWEST_PRIO + 1u];
// Table of TCBs (任务控制块表)
OS_EXT  OS_TCB   OSTCBTbl[OS_MAX_TASKS + OS_N_SYS_TASKS];



############################################################
### // uCOS-II 中奇怪的对称代码 //
############################################################
// 是为了防止长时间的关中断，影响操作系统的实时性
// 任务上锁是为了让别的任务不能获得执行权

//调度器上锁
if (OSLockNesting < 255) {
        OSLockNesting++;
}
OS_EXIT_CRITICAL();     
OS_Dummy();
OS_ENTRY_CRITICAL();
//调度器开锁
if (OSLockNesting > 0) {
        OSLockNesting--;
}
