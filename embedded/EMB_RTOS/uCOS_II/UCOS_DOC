############################################################
### % https://www.silabs.com/       (freeysh)(weihong)
############################################################



############################################################
### % uCOS-II 任务状态
############################################################
1 % __睡眠态__
任务已经被装入内存了，可是并没有准备好运行。例如上面给出的usertask
代码，以代码的形式存在于内存中，在调用OSTaskCreate()任务创建函数之
前，处于睡眠态。睡眠态的任务不会得到运行的，操作系统也不会给其设置为
运行而准务的数据结构。


2 % __就绪态__
当操作系统调用OSTaskCreate创建一任务后，任务就进入就绪态。从图中
可以看出，任务也可以从其它状态转换到就绪态。处于就绪态的任务操作系统
已经为其运行配置好了任务控制块等数据结构，当没有比其更高优先级的任务
或比其更高的任务处于阻塞状态的时候，就能被操作系统调度而进入运行态。
从就绪态到运行态，操作系统调用任务切换函数完成。


3 % __运行态__
任务真正占有CPU使用权，得到运行。这时运行的代码就是任务的代码。如
usertask。处于运行态的任务如果运行完成，就会转为睡眠态。如果有更
高优先级的任务抢占了CPU，就会转到就绪态。如果因为等待某一事件，例
如等待1秒钟的时间，如OSTimeDly(OS_TICKS_PER_SEC)，需要暂时放
弃CPU的使用权而让其它任务得以运行，就进入了阻塞态。当由于中断的到
来而使用CPU进入中断服务程序(ISR)，必然例正在运行的任务放弃CPU而
转入中断服务程序，这时被中断的任务就被挂起而进入挂起态。


4 % __阻塞态__
阻塞对于操作系统的调度，任务的协调运行是非常重要的。我们能看到图中
的运行结果，而不是只有一个高优先级的任务得到运行，就是因为usertask
在没有事情可做，等待1秒钟的时候，不是强行运行代码，而是把自己阻塞
起来，使操作系统可以调度其它的任务。当任务在等待某些还没有被释放的
资源，等待一定的赶时间等时候，要阻塞起来，等到条件满足的时候再重新
回到就绪态，以能被操作系统调度以进入运行态，这是实时系统必须要实现
的功能之一。


3 % __挂起态__
当任务在运行时，因为中断的发生，例如定时器中断每个时钟滴答(clock tick)
中断一次，而被剥夺CPU使用权，而进入挂起态。在中断返回的时候，若该任务还是
最高优先级的任务，就恢复运行，如果不是这样，只能回到就绪态。



############################################################
### % uCOS-II任务切换
############################################################
任务切换就是context switch， 是任务调度的重要部分。从字面上是上下文
切换。 任务切换是暂停一个任务的运行， 运行另一个就绪的任务。暂停一个任
务，以后以能恢复运行，必须考虑将这个任务运行的信息保存，而恢复运行的时
候需要将这些信息恢复到运行环境。
任务切换必须做环境的保存和恢复的操作。



############################################################
### % uCOS-II 函数可重入性
############################################################
1 % 函数可生重入性
函数可重入是指一个函数可以被多个任务调用，而不需要担心在任务切换的过程
中，代码的执行会产生错误。


2 % 函数不可生重入性
如果函数被多个任务调用，可能产生错误的结果，就是不可重入函数。


3 % 在多任务环境中，保证函数的可重入性
!不要使用           全局变量
!不要使用           静态变量
!不要使用           浮点运算库函数
!不要使用           C语言中的标准IO库函数



############################################################
### % uCOS-II 内核
############################################################
0 % 内核是操作系统最核心的部分，其主要的功能就是进行任务调度

1 % uCOS-II使用的是一种基于优先级的可剥型内核

3 % uCOS-II同时可以有 64 个就绪任务，每个任务都有各自的优先级
7   6   5   4   3   2   1   0
15  14  13  12  11  10  9   8
23  22  21  20  19  18  17  16
31  30  29  28  27  26  25  24
39  38  37  36  35  34  33  32
47  46  45  44  43  42  41  40
55  54  53  52  51  50  49  48
63  62  61  60  59  58  57  56



############################################################
### % uCOS-II 同步-互斥-临界区
############################################################
1 % 同步
任务是独立的，但是任务之间又有着各种各样的关系，以成为一个整体，来完成
某一项工作。有时候一个任务完成的前提是需要另一个任务给出一个结果，任务
之间的这种制约性的合作运行机制叫做任务间的同步。


2 % 互斥
A和B两个任务都要访问计算结果这个共享资源，但是在A写这个资源的同时，B
必须等待，而不能在A写到一半的时候结束A，而让B来读，这样会产生灾难性后
果。这样的共享资源称为临界资源( Critical Resource ).
这种访问共享资源的排它性就是互斥。


3 % 临界区
每个任务中访问共享资源的那段程序称为临界区( Critical section )，因为
共享资源的访问要互斥的。在临界区不允许任务切换，这是最根本的原则。回为如
果在访问共享资源的时候进行任务切换，这可能发生前面提到灾难性后果。因此，
在进入临界区访问共享资源之前，采用关中断，给调度器上锁或使用信号量的方法
达到互斥的目的。



############################################################
### % uCOS-II 信号量-互斥信号量
############################################################
1 % 信号量
在一个时刻，有些共享任务资源只可以被一个任务所占有，而有些可以被至多N个
任务所共享。前一种共享资源就好比有一把钥匙，钥匙发出去了，得到钥匙的任务
可以访问共享资源，其它请求该资源的任务必须等得到钥匙的任务把钥匙归还。
后者则可以有N把钥匙，如果N把钥匙都发完了，第N+1个请求访问共享资源的任务
就必须等待。这些钥匙就可以用信号量(semaphore)来表示。
信号量标志了共享资源的有效可被访问数量，于是要获得共享资源的访问权，就首
先要得到信号量这把钥匙。


2 % 互斥信号量
互斥信号量是一种特殊的信号量。



############################################################
### % uCOS-II 事件-事件标志组
############################################################
1 % 事件(Event)
事件(event)就是在操作系统运行过程中发生的事情。例如，任务被挂起，唤醒，
创建等。uCOS-II操作系统在处理任务的同步一通信等环节，大量使用了事件这
一概念，创建了事件控制块这样的数据结构以进行事件的管理。


2 % 事件标志组
在信号量和互斥信号量的管理中，任务请求资源，如果资源未被占用就可以继续
运行，否则只能阻塞，等待资源释放的事件发生。这种事件是单一的事件。如果
任务要等待多个事件发生，或多个事件中的某一个事件的发生就可以继续运行，
那么就应该采用事件标志组管理。
事件标志组管理的条件组合可以是多个事件都发生，也可以是多个事件中有任何
一个事件发生。尤其特别的是，还可以是多个事件都没有发生或多个事件中有任
何一相事件没有发生。



############################################################
### % uCOS-II 消息邮箱 消息队列
############################################################
0 % 邮箱(MailBox)，操作系统通过邮箱来管理任务间通信与同步
邮箱中的内容却不是信件本身，而是指向消息内容的地址！ 这个指针是 void类型
的，可以指向任何的数据结构。因而这样的设计更经济，所发送的信息范围也就更宽
邮箱中可以容纳下任何长度的数据了。


1 % 消息队列(message queue)
也用于给任务发送消息，但是这它是由多个消息组合形成的，是消息邮箱的集合，
实质上是消息邮箱的队列。一个消息邮箱可以容纳一条消息，采用消息队列，一
是可容纳多条消息，二是消息是有序的。




