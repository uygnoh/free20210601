############################################################
### % uCOS-II 临界区第3种方法实现 
############################################################
% 通过“cpu_sr”保存CPU的中断状态
#if OS_CRITICAL_METHOD = 3u
        OS_CPU_SR cpu_sr = 0u;
#endif


#define OS_ENTER_CRITICAL()     { cpu_sr = OS_CPU_SR_Save(); }
#deifne OS_EXIT_CRITICAL()      { OS_CPU_SR_Restore(cpu_sr); }


% ARM-CM3 ( C程序和汇编程序相互调用_参数传递规则 )
% R0~R3 可以用于传递参数
OS_CPU_SR_Save  % Set prio int mask to mask all (except faults)
        MRS     R0, PRIMASK
        CPSID   I
        BX      LR

OS_CPU_SR_Restore
        MSR     PRIMASK, R0
        BX      LR



############################################################
### % ARM-CM ( OS_CPU_PendSVHandler )
############################################################
OS_CPU_PendSVHandler
        CPSID   I                               ; Prevent interruption during context switch
        MRS     R0, PSP                         ; PSP is process stack pointer
        CBZ     R0, OS_CPU_PendSVHandler_nosave ; Skip register save the first time
        
        SUBS    R0, R0, #0x20                   ; R0 = R0+16
        STM     R0, {R4-R11}                    ; Save remaining regs r4-r11 on process stack
        
        LDR     R1, =OSTCBCur                   ; OSTCBCur->OSTCBStkPer = SP
        LDR     R1, [R1]
        STR     R0, [R1]                        ; R0 is Sp of process beging switched out


OS_CPU_PendSVHandler_nosave                     ; At this point, entire context of process has been saved
        PUSH    {R14}                           ; Save LR exc_return value
        LDR     R0, =OSTaskSwHook               ; OStaskSwHook
        BLX     R0
        POP     {R14}
        
        LDR     R0, =OSPrioCur                  ; OSPrioCur = OSPrioHighRdy
        LDR     R1, =OSPrioHighRdy
        LDRB    R2, [R1]
        STRB    R2, [R0];
        
        LDR     R0, =OSTCBCur                   ; OSTCBCur = OSTCBHighRdy
        LDR     R1, =OSTCBHighRdy
        LDR     R2, [R1]
        STR     R2, [R0]
        
        LDR     R0, [R2]
        LDM     R0, {R4-R11}
        ADDS    R0, R0, #0x20
        MSR     PSP, R0
        ORR     LR, LR, #0x04
        CPSIE   I
        BX      LR




############################################################
### % ARM-CM ( OSStartHighRdy )
############################################################
#define NVIC_SYSPRI14           0xEOO0ED22(系统优先级寄存器)
#define NVIC_PENDSV_PRI         0xFF
#define NVIC_INT_CTRL           0xE000ED04(中断控制状态寄存器)
#define NVIC_PENDSVSET          0x10000000


% 通过PendSV异常，引发上下文切换(此处并不是真正的上下文切换)
% 然后去启动系统的“第一个任务”
OSStartHighRdy
        LDR     R0, =NVIC_SYSPRI14      ; % 设置PendSV异常的优先级为最“低”
        LDR     R1, =NVIC_PENDSV_PRI
        STRB    R1, [R0]
        
        MOVS    R0, #0                  ; % 设置PSP的初始值为“0”，它要告诉
        MSR     PSP, R0                 ; % 上下文切换器，它是系统第一次运行

        LDR     R0, =OSRunning          ; % 设置OSRunning = TRUE
        MOVS    R1, #1
        STRB    R1, [R0]
        
        LDR     R0, =NVIC_INT_CTRL      ; % 触发PendSV异常
        LDR     R1, =NVIC_PENDSVSET
        STR     R1, [R0]
        
        CPSIE   I                       ; % 使能中断，任务就会运行

OSSTartHang                             ; % should never get here
        B       OSSTartHang



############################################################
### % uCOS-II 系统初始化工作
############################################################
void OSStart(void)
{
        if (OSrunnig == OS_FALSE) {
                OS_SchedNew(); % 查找当前就绪任务的最高优先级号码
                OSPrioCur    = OSPrioHighRdy;
                OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
                OSTCBCur     = OSTCBHighRdy;
                OSStartHighRdy();
        }
}


//它是一个静态函数，只能在文件内部被调用 
//下面( uCOS-II 优先级判定表算法 ), 只能处理 0~63 个任务优先级
static void OS_SchedNew(void)
{
        INT8U y;
        // 1 % 以就绪组中的内容，去查“y”值
        y             = OSUnMapTbl[OSRdyGrp];
        // 2 % (然后以“y”值为索引，去把就绪表中的那一行那过来)以此作为索引查OSUnMapTbl[x]
        OSPrioHighRdy = (INT8U)((y << 3u) + OSUnMapTbl[OSRdyTbl[y])
}


// % uCOS-II 优先级判定表
INT8U const OSUnMapTbl[256] = {};
