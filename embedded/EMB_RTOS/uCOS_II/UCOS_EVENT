############################################################
### // OS_InitEventList() //
############################################################
static void OS_InitEventList(void)
{
#if (OS_EVENT_EN) && (OS_MAX_EVENTS > 0u)
        #if (OS_MAX_EVENTS > 1u)
        INT16U           ix;
        INT16U           ix_next;
        OS_EVENT        *pevent1;
        OS_EVENT        *pevent2;
        
        //Clear the event table
        OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl));
        //Init. list of free EVENT control blocks
        for (ix = 0u; ix < (OS_MAX_EVENTS - 1u); ix++) {
                ix_next = ix + 1;
                pevnet1 = &OSEventTbl[ix];
                pevent2 = &OSEventTbl[ix_next];
                pevent1->OSEventType   = OS_EVENT_TYPE_UNUSED;
                pevent1->OSEventPtr    = pevent2;
                #if OS_ENENT_NAME_EN > 0u
                pevent1->OSEventName   = (INT8U *)(void *)"?"; //Unknown name
                #endif
        }
        pevent1                 = &OSEvenTbl[ix];
        pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
        pevent1->OSEventPtr     = (OS_EVENT *)0;
        #if OS_EVENT_NAME_EN > 0u
        pevent1->OSEventName    = (INT8U *)(void *)"?"; //Unknown name
        #endif
        OSEVentFreeList         = &OSEventTbl[0];
        
        
        //如果OS_MAX_EVENTS=1，也就是系统只有一个事件
        #else
        OSEventFreeList              = &OSEventTbl[0];
        OSEventFreeList->OSEventType = OS_EVENT_TYPE_UNUSED;
        OSEventFreeList->OSEventPtr  = (OS_EVENT *)0;
        
        
        #if OS_EVENT_NAME_EN > 0u
        pevent1->OSEventName    = (INT8U *)(void *)"?"; //Unknown name
        #endif
        
        #endif
#endif
}



############################################################
### // OS_EventWaitListInit() //
############################################################
#if (OS_EVENT_EN)
void OS_EventWaitListInit(OS_EVETN *pevent)
{
        INT8U i;
        pevent->OSEVentGrp = 0u;
        for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
                pevent->OSEVentTbl[i] = 0u;
        }
}
#endif




############################################################
### // OS_EvenTasktWait() //
############################################################
如果创建了事件，任务就会等待事件，如果要任务和事件建立关系的话，就使用这
个函数来实现。这个函数一定是在当前正在执行的任务中被调用。

#if (OS_EVENT)
void OS_EventTaskWait(OS_EVENT *pevent)
{
        INT8U   y;
        
        //在任务的那个方向作登记
        //Store ptr to ECB in TCB
        OSTCBCur->OSTCBEventPtr               = pevent;
        
        //在事件的那个方向作登记
        //Put task in waiting list
        pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
        pevent->OSEVentGrp                   |= OSTCBCur->OSTCBBitY;
        
        //当前任务正在申请资源或事件，那么就让当前任务从运行态转换为非就绪态。
        y            = OSTCBCur->OSTCBY;  //Task no longer ready
        OSRdyTbl[y] &= (OS_PRIO)~OSTCBCur->OSTCBBitx;
        if (OSRdyTbl[y] == 0u) {  //Clear event grp bit if this was only task pending
                OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
        }
}
#endif



############################################################
### // OS_EventTaskRemove() //
############################################################
#if (OS_EVENT_EN)
void OS_EventTaskRemove(OS_TCB *ptcb, OS_EVENT *pevent)
{
        INT8U   y;
        
        //移出事件只是在事件这里作了注销
        y                      = ptcb->OSTCBY;
        //把这个任务从它的等待列表中删除掉
        //解除事件与任务的关系
        pevent->OSEventTbl[Y] &= (OS_PRIO)~ptcb->OSTCBBitX;
        if (pevent->OSEventTbl[Y] == 0u) {
                pevent->OSEventGrp &= (OS_PRIO)~ptcb->OSTCBBitY);
        }
}
#endif



############################################################
### // OS_EventTaskRdy() //
############################################################
// 解除事件与任务的关系
#if (OS_EVENT_EN)
INT8U OS_EventTaskRdy(
        OS_EVENT    *pevent,
        void         msk;       //事件状态掩码
        INT8U        pend_stat) //申请的事件状态
{
        OS_TCB      *ptcb;
        INT8U        y;
        INT8U        x;
        INT8U        prio;
        
        #if OS_LOWEST_PRIO <= 63
        y    = OSUnMapTbl[pevent->OSEventGrp];   //Find HPT waiting for message
        x    = OSUnMapTbl[pevent->OSEvnetTbl[y]];
        prio = (INT8U)((y << 3u) + x);  //Find priority of task getting the msg
        #endif
        
        ptcb            = OSTCBPrioTbl[prio];   //Point to this task's OS_TCB
        ptcb->OSTCBDly  = 0u;       //Prevent OSTimeTick() form readying task
        
        #if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u) || (OS_MBOX_EN > 0U)
        ptcb->OSTCBMsg      = pmsg; //Send message directly to waiting task
        #else
        pmsg                = pmsg; //Prevent compiler warning if not used
        #endif
        
        ptcb->OSTCBStat    &= (INT8U)~msk; //Clear bit associated with event type
        ptcb->OSTCBStatPend = pend_stat;   //Set pend status of post or abort
        
        //如果这个任务不是挂起态，那么就让它变成就绪态
        if ((ptcb->OSTCBStat &  OS_STAT_SUSPEND) == OS_STAT_RDY) {
                OSRdyGrp     |= ptcb->OSTCBBitY;
                OSRdyTbl[y]  |= ptcb->OSTCBBitX;
        }
        
        //Remove this task form event wait list
        OS_EventTaskRemove(ptcb, pevent);
        
        #if (OS_EVENT_MULTI_EN > 0u)
        //Remove this task from events' wait lists
        if (ptcb->OSTCBEventMultiPtr |= (OS_EVENT **)0) {
                OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
                //Return this task from events' wait lists
                ptcb->OSTCBEventPtr = (OS_EVENT *)pevent;
        }
        #endif
        
}
#endif



############################################################
### // 信号量的创建 //
############################################################
OS_EVENT *OSSemCreate(INT16U cnt)
{
        OS_EVENT *pevent;
        #if OS_CRITICAL_METHOD == 3u
        OS_CPU_SR cpu_sr = 0;
        #endif
        
        #ifdef OS_SAFETY_CRITICAL_IEC61508
        if (OSSafetyCriticalStartFlag == OS_TRUE) {
                OS_SAFETY_CRITICAL_EXCEPTION();
        }
        #endif
        
        if (OSIntNesting > 0u) {
                return ((OS_EVENT *)0);
        }
        
        OS_ENTER_CRITICAL();
        pevent = OSEventFreeList;
        if (OSEventFreeList != (OS_EVENT *)0) {
                //把事件空闲链表的表头，指向下一个节点
                OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
        }
        OS_EXIT_CRITICAL();
        
        if (pevent != (OS_EVENT *)0) {
                pevent->OSEventType     = OS_EVENT_TYPE_SEM;
                pevent->OSEventCnt      = cnt;
                //从事件空闲链表摘1个，事件列表控制块
                pevent->OSEvnetPtr      = (void *)0;
        
                #if OS_EVENT_NAME_EN > 0u
                pevent->OSEventName             = (INT8U *)(void *)"?";
                #endif 
                
                OS_EventWaitListInit(pevent);
        }
        return (pevent);
}



############################################################
### // 信号量请求 //
############################################################
void OSSemPend(
        OS_EVENT        *pevent,        
        INT32U           timeout,       //超时参数
        INT8U           *perr)          //错误参数
{
        #if OS_CRITICAL_METHOD == 3u
        OS_CPU_SR cpu_sr = 0u
        #endif
        
        #ifdef OS_SAFETY_CRITICAL
        if (perr == (INT8U *)0) {
                OS_SAFETY_CRITICAL_EXCEPTION();
        }
        #endif
        
        #if OS_ARG_CHK_EN > 0u
        //无效的事件
        if (pevent == (OS_EVENT *)0) {
                *perr = OS_ERR_PEVENT_NULL;
                return;
        }
        #endif
        
        //无效的事件类型
        if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {
                *perr = OS_ERR_EVENT_TYPE;
                return;
        }
        
        //不能从中断申请信号量
        if (OSIntNesting > 0u) {
                *perr = OS_ERR_PEND_ISR;
                return;
        }
        //调度器加锁的情况下，不能申请信号量
        if (OSLockNesting > 0u) {
                *perr = OS_ERR_PEND_LOCKED;
                return;
        }
        
        OS_ENTER_CRITICAL();
        if (pevent->OSEventCnt > 0u) {
                pevent->OSEventCnt--;
                OS_EXIT_CRITICAL();
                *perr = OS_ERR_NONE;
                return;
        }
        
        OSTCBCur->OSTCBStat     |= OS_STAT_SEM;
        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
        OSTCBCur->OSTCBDly       = timeout;
        OS_EventTaskWait(pevent);
        OS_EXIT_CRITICAL();
        
        OS_Sched();
        
        OS_ENTER_CRITICAL();
        switch (OSTCBCur->OSTCBStatPend) {
        case OS_STAT_PEND_OK:                   //等到了
                *perr = OS_ERR_NONE;
                break;
        case OST_STAT_PEND_ABORT:               //被强制终止了
                *perr = OS_ERR_PEND_ABORT;
                break;
        case OS_STAT_PEND_TO:                   //超时了
        default:                                
                OS_EventTaskRemove(OSTCBCur, pevent);
                *perr = OS_ERR_TIMEOUT;
                break;
        }
        OSTCBCur->OSTCBStat     = OS_STAT_RDY;
        OSTCBCur->OSTCBStatPend = OS_STAT_PEND_OK;
        OSTCBCur->OSTCBEventPtr = (OS_EVENT *)0;
        
        #if (OS_EVETNT_MULTI_EN > 0u)
        OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
        #endif
        OS_EXIT_CRITICAL();
}


############################################################
### // 信号量归还 //
############################################################
INT8U OSSemPost(OS_EVENT *pevent)
{
        #if OS_CRITICAL_METHOD == 3u
        OS_CPU_SR cpu_sr = 0;
        #endif
        
        #if OS_ARG_CHK_EN > 0
        if (pevent == (OS_EVENT *)0) {
                return (OS_ERR_PEVENT_NULL);
        }
        #endif
        if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {
                return (OS_ERR_EVENT_TYPE);
        }
        OS_ENTER_CRITICAL();
        if (pevent->OSEventGrp != 0) {
                (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
                OS_EXIT_CRITICAL();
                OS_Sched();
                return (OS_ERR_NONE);
        }
        if (pevent->OSEventCnt < 65535u) {
                pevent->OSEventCnt++;
                OS_EXIT_CRITICAL();
                return (OS_ERR_NONE);
        }
        OS_EXIT_CRITICAL();
        return (OS_ERR_SEM_OVF);
}



############################################################
### // 信号量删除 //
############################################################
OS_EVENT *OSSemDel(
        OS_EVENT        *pevent,
        INT8U            opt,
        INT8U           *perr)
{
        #if OS_CRITICAL_METHOD == 3u
        OS_CPU_SR cpu_sr = 0u
        #endif
        
        #ifdef OS_SAFETY_CRITICAL
        if (perr == (INT8U *)0) {
                OS_SAFETY_CRITICAL_EXCEPTION();
        }
        #endif
        
        #if OS_ARG_CHK_EN > 0u
        if (pevent == (OS_EVENT *)0) {
                *perr = OS_ERR_PEVENT_NULL;
                return (pevent);
        }
        #endif
        
        if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {
                *perr = OS_ERR_PEVENT_TYPE;
                return (pevent);
        }
        if (OSIntNesting > 0u) {
                *perr = OS_ERR_DEL_ISR;
                return (pevent);
        }
        OS_ENTER_CRITICAL();
        
        if (pevent->OSEventGrp != 0) {
                tasks_waiting = OS_TRUE;
        } else {
                tasks_waiting = OS_FALSE;
        }
        
        switch (opt) {
        case OS_DEL_NO_PEND:
                //只有任务在没有申请信号量的情况下，才删除操作
                if (tasks_waiting == OS_FALSE) {
                
                #if OS_EVENT_NAME_EN > 0u
                        pevent->OSEventType     = (INT8U *)(void *)"?";
                #endif
                        pevent->OSEventType     = OS_EVENT_TYPE_UNUSED;
                        pevent->OSEventPtr      = OSEventFreeList;
                        pevent->OSEventCnt      = 0u;
                        OSEventFreeList         = pevent;
                        OS_EXIT_CRITICAL();
                        *perr                   = OS_ERR_NONE;
                        pevent_return           = (OS_EVENT *)0;
                } else {
                        OS_EXIt_CRITICAL();
                        *perr                   = OS_ERR_TASK_WAITING;
                        pevnet_return           = pevent;
                }
                break;
        case OS_DEL_ALWAYS:
                while (pevent->OSEventGrp != 0) {
                        //解除任务与事件的关系
                        (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
                }
                #if OS_EVENT_NAME_EN > 0u
                pevent->OSEventType     = (INT8U *)(void *)"?";
                #endif
                
                pevnet->OSEventType     = OS_EVENT_TYPE_UNUSED;
                pevent->OSEventPtr      = OSEventFreeList;
                pevent->OSEventCnt      = 0u;
                OSEventFreeList         = pevent;
                OS_EXIT_CRITICAL();
                if (tasks_waiting == OS_TRUE) {
                        OS_Sched();
                }
                *perr                   = OS_ERR_NONE;
                pevent_return           = (OS_EVENT *)0;
                break;
        default:
                OS_EXIT_CRITICAL();
                *perr                   = OS_ERR_INVALID_OPT;
                pevent_return           = pevent;
                break;      
        }

        return (pevent_return);
}



############################################################
### // 检查这个信号量对应的那个资源是否可用 //
### // 或者这个信号量对应的那个事件是否发生 //
############################################################
//如果申请的这个信号量不可用，那么往下走，也就是说这个函数所申请的信号量
//是可有可无的。这个函数不影响程序向下执行。它不会发生任务的切换。
return: 
        >  0 申请到了
        == 0 没有申请到

#if OS_SEM_ACCEPT_EN > 0u
INT16U OSSemAccept(OS_EVNET *pevent)
{
        INT16U  cnt;
        #if OS_CRITICAL()
        OS_CPU_SR cp_sr = 0;
        #endif
        
        #if OS_ARG_CHK_EN > 0
        if (pevnet == (OS_EVENT *)0) {
                return (0u);
        }
        #endif
        
        if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {
                return (0u);
        }
        OS_ENTER_CRITICAL();
        cnt = pevnet->OSEventCnt;
        if (cnt > 0u) {
                pevnet->OSEventCnt--;
        }
        OS_EXIT_CRITICAL();
        return (cnt);
}
#endif



############################################################
### // //
############################################################
INT8U OSSemPendAbort(
        OS_EVENT        *pevent,
        INT8U            opt,
        INT8U           *perr)
{
        INT8U   nbr_tasks; //任务个数
        #if OS_CRITICAL_METHOD == 3u
        OS_CPU_SR cpu_sr = 0;
        #endif
        
        #ifdef OS_SAFETY_CRITICAL
        if (perr == (INT8U *)0) {
                OS_SAFETY_CRITICAL_EXCEPTION();
        }
        #endif
        
        #if OS_ARG_CHK_EN > 0u
        if (perr == (INT8U *)0) {
                *perr = OS_ERR_PEVENT_NULL;
                return (0u);
        }
        #endif
        if (pevnet->OSEventType != OS_EVENT_TYPE_SEM) {
                *perr = OS_ERR_EVENT_TYPE;
                return (0u);
        }
       OS_ENTER_CRITICAL();
       
       //如果不等于“0”，说明有任务在申请这个信号量
       if (pevnet->OSEvntGrp != 0) {
                nbr_tasks = 0u;
                switch (opt) {
                case OS_PEND_OPT_BROADCAST:     //广播模式
                        while (pevent->OSEventGrp != 0u) {
                                //它只在事件那里和信号量解除
                                (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
                                nbr_tasks++;
                        }
                        break;
                case OS_PEND_OPT_NONE:          //单播模式
                default:
                        //它只在事件那里和信号量解除
                        (void)OS_EvnetTaskRdy(pevnet, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
                        nbr_tasks++;
                        break;
                }
                OS_EXIT_CRITICAL();
                OS_Sched();
                *perr = OS_ERR_PEND_ABORT:
                return (nbr_tasks);
       }
       OS_EXIT_CRITICAL();
       *perr = OS_ERR_NONE;
       return (0u); //没有任务在申请这个信号量
}



