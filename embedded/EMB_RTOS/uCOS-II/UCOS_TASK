############################################################
### % OS_TCB
############################################################
typedef struct os_tcb {
        OS_STK          *OSTCBStkPtr;   //任务栈顶指针
        
        stuct os_tcb    *OSTCBNext;
        stuct os_tcb    *OSTCBPrev;
        
        INT32U           OSTCBDly;      //任务等待超时
        INT8U            OSTCBStat;     //任务状态
        INT8U            OSTCBStatPend; //任务请求状态
        INT8U            OSTCBPrio;     //任务优先级(0 最高)
        
        INT8U            OSTCBX;
        INT8U            OSTCBY;
        OS_PRIO          OSTCBBitX;
        OS_PRIO          OSTCBBitY;

} OS_TCB;



############################################################
### % 任务空闲链表    任务就绪链表
############################################################
uCOS-II将任务控制块分成两个链表管理，这就是空闲任务链表和就绪任务链表。
所谓空闲任务控制块，是指未分配给某个任务的任务控制块。创建一个新任务，前
提条件就是系统里还有这样的空闲任务块。就绪链表则是将所有的就绪任务连接在
一起，如果有新的任务就绪，就要将其任务控制块从空闲链表中取出，加入到就绪
链表中。

1 % 任务空闲链表(OSTCBFreeList)使用单向链表


2 % 任务就绪链表(OSTCBList)使用双向链表



############################################################
### % 任务优先级指针表
############################################################
任务优先级指针表也就是任务优先级指针数组，在uCOS-II任务管理中频繁使用。
它是用来获取某优先级的任务的任务控制块地址。 它的定义为：
OS_TCB *OSTCBPrioTbl[OS_LOWEST_PRIO + 1]
OS_LOWEST_PRIO为最低优先级的任务优先级，因为低优先级的任务数值最大，
而任务优先级是从 0 开始的，所以其实OS_LOWEST_PRIO+1就是任务的数量。
数组OSTCBPrioTbl就是具有最多任务数个元素，它的类型是指向任务控制块
的指针。



############################################################
### % 任务堆栈
############################################################
所谓堆栈，就是在存储器中按数据“后进先出LIFO(Last In First Out)”的原
则组织的连续存储空间。因此，堆栈这种数据结构最大的特点就是最后进去的最先
出来。 任务堆栈的定义：
#define TASK_STK_SIZE           512
OS_STK TaskStk[OS_MAX_TASKS][TASK_STK_SIZE]
% TASK_STK_SIZE是每个任务堆栈的大小，这里设置为512
% OS_MAX_TASKS是用户任务的数量



############################################################
### % 任务就绪表和就绪组
############################################################
内核在进行任务调度的时候，必须知道那个任务在运行，那个任务是就绪的最高优
级的任务。实时任务调度的速度关键在于速度，要求无论系统运行情况如何，调度
的时间是确定的不能把时间都用在调度上。因此就需要设计高效的多任务调度方法
查找高优先级的任务，与正在运行任务的优先级进行比较以确定是否进行任务切换
是内核在每个时钟中断都需要做的事情。为满足这样的需要，uCOS-II的开发者采
用了就绪表和就绪组这样的数据结构，围绕它们定义了 2 张查找表.
-2 % 任务优先级
0 0  1 1 1          1 1 1
       |              | 
       |              |
       \              \
       Y              X
    OSRdyGrp        OSRdyTbl
         7   6   5   4   3   2   1   0
_______________________________________         
0      | 7   6   5   4   3   2   1   0
1      | 15  14  13  12  11  10  9   8
2      | 23  22  21  20  19  18  17  16
3      | 31  30  29  28  27  26  25  24
4      | 39  38  37  36  35  34  33  32
5      | 47  46  45  44  43  42  41  40
6      | 55  54  53  52  51  50  49  48
7      | 63  62  61  60  59  58  57  56    
_______|_______________________________             
    
-1 % 任务就绪表 OSRdyTbl[]
uCOS-II在RAM中设立了一个记录表，系统中的每个任务都在这个表中占据一个位置，
并用这个位置的状态(0 | 1)来表示任务是否处于就绪态。这个表就中任务就绪状态表。
用一数据类型为INT8U的数组OSRdyTbl[]来充当任务就绪表。由于每个任务的就绪状
态只占据一位，OSRdyTbl[]数组的一个元素就可以表达 8 个任务的就绪状态。
( 1 表示就绪， 0 表示非就绪 )


0 % 任务就绪组 OSRdyGrp
为了便于就绪表的查找，uCOS-II又定义了个数据类型为INT8U的变量OSRdyGrp，
并使该变量的每一个位都对应OSRdyTbl[]的一个任务组，即OSRdyTbl[]的一个
元素。如果某任务组中有任务就绪，就在变量OSRdyGrp里把该任务组所对应的位
置“1”，否则置“0”。 例如: 
OSRdyGrp = (11100101)表示OSRdyTbl{0 组, 2 组, 5 组, 6 组, 7 组}
任务组中有任务就绪。



% 任务就绪表和任务就绪组定义
__________________________________________________________
typedef unsigned char INT8U;
#define OS_RDY_TBL_SIZE         ((OS_LOWEST_PRIO) / 8 + 1)
INT8U OSRdyTbl[OS_RDY_TBL_SIZE];        //任务就绪表
INT8U OSRdyGrp;                         //任务就绪组
__________________________________________________________



1. uCOS-II 登记
指的是当某个任务处于就绪状态时，系统将该任务登记在任务就绪表中，即在就
绪表中将该任务对应的位设置为1我们知道，ucosii系统最大支持64个任务数，
且每个任务的优先级不能相同，所以优先级就是每个任务的ID，在程序中，用下
面代码把优先级为prio的任务设置为就绪状态：
OSRdyGrp             |= OSMapTbl[ prio >>3 ];    % 设置就绪标志组对应的组对应的位为1
OSRdyTbl[ prio >>3 ] |= OSMapTbl[ prio & 0x07 ]; % 把优先级值对应的就绪表中的位置为1

2. uCOS-II 注销
和登记相反，即把prio优先级任务对应的位置0
if ( ( OSRdyTbl[ prio >>3 ] &= ~OSMapTbl[ prio &0x07 ] ) == 0 ) 
        OSRdyGrp &= ~OSMapTbl[prio >>3 ];

3. uCOS-II 查找最高优先级就绪任务
% OSUnMapTal[ ]为什么能实现这个效果，这就是这里的操作系统最巧妙之处了
y    = OSUnMapTbl[ OSRdyGrp ];     % 获得优先级别的D5,D4,D3位,先找出是哪一组
x    = OSUnMapTbl[ OSRdyTbl[ y ] ];% 获得优先级别的D2,D2,D0位,再从哪一组中找出是哪一位        
prio = ( y<<3 ) + x;               % 获得就绪任务的优先级值



