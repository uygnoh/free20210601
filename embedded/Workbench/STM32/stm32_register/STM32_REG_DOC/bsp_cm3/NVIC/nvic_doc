############################################################
### % Cortex-M3 NVIC(内嵌向量中断控制器)
############################################################
0           111  ______________________，所有8位用于指定响应优先级
1           110  最高1位用于指定抢占式优先级，最低7位用于指定响应优先级
2           101  最高2位用于指定抢占式优先级，最低6位用于指定响应优先级
3           100  最高3位用于指定抢占式优先级，最低5位用于指定响应优先级
4           011  最高4位用于指定抢占式优先级，最低4位用于指定响应优先级
5           010  最高5位用于指定抢占式优先级，最低3位用于指定响应优先级
6           001  最高6位用于指定抢占式优先级，最低2位用于指定响应优先级
7           000  最高7位用于指定抢占式优先级，最低1位用于指定响应优先级  
_______________________________________________________________
% Cortex-M3允许具有较少中断源时使用较少的寄存器位指定中断源的优先级，
% STM32把指定中断优先级的寄存器位减少到4位，这4个寄存器位的分组方式如下
第0组：所有4位用于指定响应优先级
第1组：最高1位用于指定抢占式优先级，最低3位用于指定响应优先级
第2组：最高2位用于指定抢占式优先级，最低2位用于指定响应优先级
第3组：最高3位用于指定抢占式优先级，最低1位用于指定响应优先级
第4组：所有4位用于指定抢占式优先级
_______________________________________________________________
1）抢占优先级越小，优先级越高；相同抢占优先级的中断不能嵌套；

2）相同抢占优先级N个中断发生时，响应优先级越小的中断首先执行（不能嵌套），
   如果响应优先级也均相同，则根据各中断对应向量表的位置来确定，向量表中
   越靠前的中断先响应。
   
   
% “SCB->AIRCR”寄存器的[10:8]位，决定了IP寄存器[7:4]位
  的抢占与响应位的分配结果。
N      SCB->AIRC[10:8]    IPR[7:4]       分配结果
_______________________________________________________________
0           111             0:4        0位抢占优先级, 4位响应优先级
1           110             1:3        1位抢占优先级, 3位响应优先级
2           101             2:2        2位抢占优先级, 2位响应优先级
3           100             3:1        3位抢占优先级, 1位响应优先级
4           011             4:0        4位抢占优先级, 0位响应优先级   
_______________________________________________________________


% 微控制器软件接口标准<CMSIS>
% (Cortex Microcontroller Software Interface Standard) 
% 是 Cortex-M 处理器系列的与供应商无关的硬件抽象层
__I     /* defines 'read only' permissions    */定义只读允许位
__O     /* defines 'write only' permissions   */定义只写允许位
__IO    /* defines 'read / write' permissions */定义读/写允许位
 
 
 
############################################################
### % CPUID寄存器 (0xE000_ED00)
############################################################
31:24           % 实现者代码, ARM=0x41
23:20           % 实现定义的变种号
19:16           % 常量
15:4            % Part编号
3:0             % 修订号



############################################################
### % 中断控制及状态寄存器ICSR(地址:0xE000_ED04)
############################################################
31      NMIPENDSET(R/W)     % 写 1 以悬起 NMI,因为 NMI 的优先级最高且从
                            % 不掩蔽,在置位此位后将立即进入 NMI 服务例程
28      PENDSVSET(R/W)      % 写 1 以悬起 PendSV
27      PENDSVCLR(W)        % 写 1 以清除 PendSV 悬起状态
26      PENDSTSET(R/W)      % 写 1 以悬起 SysTick。
25      PENDSTCLR(W)        % 写 1 以清除 SysTick 悬起状态
23      ISRPREEMPT(R)       % 为 1 时,则表示一个悬起的中断将在下一步时进
                            % 入活动状态(用于单步执行时的调试目的)
22      ISRPENDING(R)       % 1=当前正有外部中断被悬起(不包括 NMI)
21:12   VECTPENDING(R)      % 悬起的 ISR 的编号。如果不止一个中断悬起,则
                            % 它的值是这引动中断中,优先级最高的那一个。
11      RETTOBASE(R)        % 如果异常返回后将回到基级(base level),并且没有
                            % 其它异常悬起时,此位为 1。若是在线程模式下,
                            % 在某个服务例程中,有不止一级的异常处于活动
                            % 状态,或者在异常没有活动时执行了异常服务例
                            % 程(此时执行返回指令将产生 fault。此乃高危行
                            % 为,大虾也需慎用),则此位为 0
9:0     VECTACTIVE(R)       % 当前活动的ISR编号,该位段指出当前运行中的ISR
                            % 是哪个中断的(提供异常序号),包括NMI和硬
                            % fault。 如果多个异常共享一个服务例程,该例程可根据
                            % 本位段的值来判定是哪一个异常的响应导致它的执行。把
                            % 本位段的值减去16,就得到了外中断的编号,并可以用此
                            % 编号来操作外中断相关的使能/除能等寄存器



############################################################
### % 向量表偏移量寄存器(VTOR) 0xE000_ED08
############################################################ 
 


############################################################
### % 应用程序中断及复位控制寄存器(AIRCR) (0xE000_ED0C)
############################################################ 
31:16       VECTKEY         % 访问钥匙:任何对该寄存器的写操作,都必须
                            同时把 0x05FA 写入此段,否则写操作被忽略。
                            若读取此半字,则 0xFA05
15          ENDIANESS       % 指示端设置。1=大端(BE8),0=小端。此值
                            是在复位时确定的,不能更改。 
10:8        PRIGROUP        % 优先级分组
2           SYSRESETREQ     % 请求芯片控制逻辑产生一次复位
1           VECTCLRACTIVE   % 清零所有异常的活动状态信息。通常只在调试
                            时用,或者在 OS 从错误中恢复时用。
0           VECTRESET       % 复位 CM3 处理器内核(调试逻辑除外),但是
                            此复位不影响芯片上在内核以外的电路
                            
                            
 
############################################################
### % 系统控制寄存器 (0xE000_ED10)
############################################################
4           SEVONPEND       % 发生异常悬起时请发送事件,用于在一个新的中
                            断悬起时从 WFE 指令处唤醒。不管这个中断的
                            优先级是否比当前的高,都唤醒。如果没有 WFE
                            导致睡眠,则下次使用 WFE 时将立即唤醒
                            
2           SLEEPDEEP       % 当进入睡眠模式时,使能外部的 SLEEPDEEP 信号
                            以允许停止系统时钟                            

1           SLEEPONEXIT     % 激活“SleepOnExit”功能



############################################################
### % 配置与控制寄存器 (0xE000_ED14)
############################################################
9       STKALIGN            % 在响应异常的自动入栈操作时,强制 SP 对
                            齐到双字地址上
8       BFHFNMIGN           % 在硬 fault 与 NMI 服务例程中忽略数据总线fault
4       DIV_0_TRP           % 除数为零时陷入用法 fault
3       UNALIGN_TRP         % 访问未对齐时陷入用法 fault
1       USERSETMPEND        % 如果为 1,则允许用户代码设置 STIR
0       NONBASETHRDENA      % 非基于线程模式使能位。如果为 1,则允许异
                            常服务例程通过修改 EXC_RETURN,使其在
                            线程模式下执行



############################################################
### % % 系统异常优先级寄存器阵列(0xE000_ED18 - 0xE000_ED23)
############################################################ 
0xE000_ED18     PRI_4       % 存储器管理 fault 的优先级
0xE000_ED19     PRI_5       % 总线 fault 的优先级
0xE000_ED1A     PRI_6       % 用法 fault 的优先级
0xE000_ED1B     ‐ ‐ ‐ ‐
0xE000_ED1C     ‐ ‐ ‐ ‐
0xE000_ED1D     ‐ ‐ ‐ ‐
0xE000_ED1E     ‐ ‐ ‐ ‐
0xE000_ED1F     PRI_11      % SVC 优先级
0xE000_ED20     PRI_12      % 调试监视器的优先级
0xE000_ED21     ‐ ‐ ‐ ‐
0xE000_ED22     PRI_14      % PendSV 的优先级
0xE000_ED23     PRI_15      % SysTick 的优先级



############################################################
### % 系统Handler控制及状态寄存器SHCSR(地址:0xE000_ED24)
############################################################
[18]    USGFAULTENA(R/W)    % 用法 fault 服务例程使能位
[17]    BUSFAULTENA(R/W)    % 总线 fault 服务例程使能位
[16]    MEMFAULTENA(R/W)    % 存储器管理 fault 服务例程使能位
[15]    SVCALLPENDED(R/W)   % SVC 悬起中
[14]    BUSFAULTPENDED(R/W) % 总线 fault 悬起中,细节同上
[13]    MEMFAULTPENDED(R/W) % 存储器管理 fault 悬起中,细节同上
[12]    USGFAULTPENDED(R/W) % 用法 fault 悬起中,细节同上
[11]    SYSTICKACT(R/W)     % SysTick 异常活动中
[10]    PENDSVACT(R/W)      % PendSV 异常活动中
[9 ]    ---
[8 ]    MONITORACT(R/W)     % Monitor 异常活动中
[7 ]    SVCALLACT(R/W)      % SVC 异常活动中
6:4]    ---
[3 ]    USGFAULTACT(R/W)    % 用法 fault 异常活动中
[2 ]    ---
[1 ]    BUSFAULTACT(R/W)    % 总线 fault 异常活动中
[0 ]    MEMFAULTACT(R/W)    % 存储器管理 fault 异常活动中






        
        
############################################################
### % 中断建立全过程的演示
############################################################
1 当系统启动后,先设置优先级组寄存器。缺省情况下使用组0(7位抢占优先级,
  1位亚优先级)
2 如果需要重定位向量表,先把硬fault和NMI服务例程的入口地址写到新表项
  所在的地址中。
3 配置向量表偏移量寄存器,使之指向新的向量表(如果有重定位的话)
4 为该中断建立中断向量。因为向量表可能已经重定位了,保险起见需要先读取向量
  表偏移量寄存器的值,再根据该中断在表中的位置,计算出服务例程入口地址应写入
  的表项,再填写之。如果一直使用ROM中的向量表,则无需此步骤。
5 为该中断设置优先级。
6 使能该中断
_________________________________________________
LDR     R0,     =0xE000ED0C  ; % 应用程序中断及复位控制寄存器
LDR     R1,     =0x05FA0500  ; % 使用优先级组 5 (2/6)
STR     R1,     [R0]         ; % 设置优先级组

MOV     R4,     #8           ; % ROM中的向量表
LDR     R5,     =(NEW_VECT_TABLE+8)
LDMIA   R4!,    {R0-R1}      ; % 读取NMI和硬Fault的向量
STMIA   R5!,    {R0-R1}      ; % 拷贝它们的向量到新表中
LDR     R0,     =0xE000ED08  ; % 向量表偏移量寄存器的地址
LDR     R1,     =NEW_VECT_TABLE
STR     R1,     [R0]         ; % 把向量表重定位
LDR     R0,     =IRQ7_Handler; % 取得IRQ#7 服务例程的入口地址
LDR     R1,     =0xE000ED08  ; % 向量表偏移量寄存器的地址
LDR     R1,     [R1]
ADD     R1,     R1,#(4*(7+16));% 计算IRQ#7 服务例程的入口地址

LDR     R0,     =0xE000E400  ; % 外部中断优先级寄存器陈列的基地址
MOV     R1,     =0xC0
STRB    R1,     [R0, #7]     ; % 把IRQ#7的优先级设置为0xC0

LDR     R0,     =0xE000E100  ; % SETEN寄存器的地址
MOV     R1,     #(1<<7)      ; % 置位 IRQ#7的使能位
STR     R1,     [R0]         ; % 使能 IRQ#7
_________________________________________________




############################################################
### % 中断控制器类型寄存器ICTR(地址:0xE000_E004)
############################################################
4:0     INTLINESUM(R)       % 中断输入的数量,以 32 为粒度,如
        0=1  至 32
        1=33 至 64
        2=65 至 96
        ...
        


############################################################
### % SysTick定时器
############################################################
% Cortex‐M3处理器内部包含了一个简单的定时器。
因为所有的CM3芯片都带有这个定时器,软件在不同CM3器件间的移植工作得以化简
该定时器的时钟源可以是内部时钟(FCLK,CM3上的自由运行时钟),或者是外部时钟
( CM3处理器上的STCLK信号 ).不过,STCLK的具体来源则由芯片设计者决定,因此
不同产品之间的时钟频率可能会大不相同, 你需要检视芯片的器件手册来决定选择什
么作为时钟源。


% SysTick控制及状态寄存器(地址:0xE000_E010)
_________________________________________________
[16]    COUNTFLAG(R)    % 如果在上次读取本寄存器后,SysTick已经数到了0, 
                        % 则该位为 1。如果读取该位,该位将自动清零
[2 ]    CLKSOURCE(R/W)  % “0” 外部时钟源(STCLK)/8, “1”内核时钟(FCLK)
[1 ]    TICKINT(R/W)    % “1” SysTick倒数到0时产生SysTick异常请求
                        % “0” 数到0时无动作
[0 ]    ENABLE(R/W)     % SysTick 定时器的使能位


% SysTick重装载数值寄存器(地址:0xE000_E014) 
[23:0]              % 当倒数至零时,将被重装载的值
_________________________________________________    


% SysTick当前数值寄存器(地址:0xE000_E018)    
_________________________________________________
[23:0]              % 读取时返回当前倒计数的值,写它则使之清零,
                    % 同时还会清除在 SysTick 控制及状态寄存器中的
                    % COUNTFLAG 标志


% SysTick校准数值寄存器(地址:0xE000_E01C)
_________________________________________________
[31]                % 1=没有外部参考时钟(STCLK 不可用)
                    % 0=外部参考时钟可用
[30]                % 1=校准值不是准确的 10ms
                    % 0=校准值是准确的 10ms
[23:0]              % 10ms 的时间内倒计数的格数。芯片设计者应该通
                    % 过 Cortex‐M3 的输入信号提供该数值。若该值读
                    % 回零,则表示无法使用校准功能




############################################################
### % NVIC(外部中断控制寄存器组)
############################################################
_____________________________________________________________________
/* % 中断使能寄存器 (0xE000_E100 – 0xE000_E11C) */
__IO uint32_t ISER[8]; /* Interrupt Set Enable Register           */
/* % 中断除能寄存器 (0xE000E180 - 0xE000_E19C) */
__IO uint32_t ICER[8]; /* Interrupt Clear Enable Register         */
/* % 悬起寄存器族 (0xE000_E200 – 0xE000_E21C) */
__IO uint32_t ISPR[8]; /* Interrupt Set Pending Register          */
/* % 解悬寄存器族 (0xE000E280 - 0xE000_E29C) */
__IO uint32_t ICPR[8]; /* Interrupt Clear Pending Register        */
/* % 中断活动状态寄存器族 (0xE000_E300_0xE000_E31C) */
__IO uint32_t IABR[8]; /* Interrupt Active bit Register           */
/* % 中断优先级寄存器阵列 (0xE000_E400 – 0xE000_E4EF) */
__IO uint8_t  IP[240]; /* Interrupt Priority Register (8Bit wide) */
/* % 软件触发中断寄存器STIR (0xE000_EF00) */
__O  uint32_t STIR;    /* Software Trigger Interrupt Register     */
_____________________________________________________________________  



