############################################################
### % STM32优先级(core_cm3.h)
############################################################
% 设置优先级分组
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
    uint32_t reg_value;
    /* % 优先级分组只能是：0~7 */
    uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL); 
    
    /* % 读取以前寄存器的配置信息 */
    reg_value  =  SCB->AIRCR;
    /* % 清除需要改变的位 */
    reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));
    /* % 写入密钥和“3”位分组信息 */
    reg_value  =  (reg_value                                   |
                  ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                  (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos) );
    SCB->AIRCR =  reg_value;
}
% 设置抢占优先级，响应优先级
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
    if ((int32_t)(IRQn) >= 0)
    {
        NVIC->IP[((uint32_t)IRQn)]               = 
        (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    }
    else
    {
        SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = 
        (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    }
}




############################################################
### % SysTick优先级设置(core_cm3.h)
############################################################
static __INLINE uint32_t SysTick_Config(uint32_t ticks)
{ 
    //  判断 tick 的值是否大于 2^24，如果大于，则不符合规则
    if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);

    // 初始化reload寄存器的值    
    //之所以要减1 个人认为是因为计数是从零开始的
    SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;  

    // 配置中断优先级，配置为15，默认为最低的优先级
    //（1<<4为16，—1为15）
    NVIC_SetPriority(SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1); 

    // 初始化counter的值为0    
    SysTick->VAL   = 0; 

    // 配置 systick 的时钟为 72M
    // 使能中断
    // 使能systick
    SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk | 
                     SysTick_CTRL_TICKINT_Msk   | 
                     SysTick_CTRL_ENABLE_Msk;                    
    return(0);     
}
% Systick模块初始化配置函数（Systick_config）中设定模块中断优先级的函数为：
NVIC_SetPriority((SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);
1 % 参数SysTick_IRQn为systick基址，这个没什么好说的
2 % 关键在参数 (1<<__NVIC_PRIO_BITS) - 1);
这个参数即占先优先级值，其中—NVIC_PRIO_BITS是stm32.h中的宏定义，库函数默认为4，
表示用4位表示占先优先级，因为m3内核只有4位用来表示占先优先级和响应优先级，那么响应
优先级就剩下0位了，也就是没有响应优先级之分，
按照上式计算若NVIC_PRIO_BITS为4则占先优先级为15，即最低优先级值
依次可类推，即 (1<<__NVIC_PRIO_BITS) - 1);表示的是可用的最低优先级（1<<4为16，—1为15），
将后面那个红色的1改为其他值即可改变此模块占先优先级





############################################################
### % NVIC优先级设置
############################################################
% 设置优先级分组
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup);
NVIC_SetPriorityGrouping(PriorityGroup);
#define NVIC_SetPriorityGrouping    __NVIC_SetPriorityGrouping
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup);



% 设置抢占优先级，响应优先级
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority);
NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, \
                                               uint32_t PreemptPriority, uint32_t SubPriority);



############################################################
### % 中断
############################################################
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn);
NVIC_EnableIRQ(IRQn);
#define NVIC_EnableIRQ              __NVIC_EnableIRQ
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
  }
}
















