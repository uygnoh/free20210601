############################################################
### % 单总线器件ROM码64-bit
############################################################
### % 64位唯一的ROM码
%___________________________________
MSB                              LSB
(8位CRC校验码 + 48位串行数据 + 8位家庭码)
% 主机根据ROM码的前56位来计算CRC值，然后与ROM中高8位的CRC
% 值比较，判断接收的ROM是否正确，CRC码的多项式函数为：CRC=x8+x5+x4+1



############################################################
### % DS18B20数字温度计寄存器
############################################################
SCRATCHPAD(POWER-UP STATE)_9                    EEPROM_3
___________________________________________________________
Byte_0  % Temperature LSB(50h)
Byte_1  % Temperature MSB(05h)
Byte_2  % TH Register or User Byte 1*   <===>   TH Register or User Byte 1
Byte_3  % TL Register or User Byte 2*   <===>   TL Register or User Byte 2
Byte_4  % Configuration Register*       <===>   Configuration Register
Byte_5  % Reserved(FFh)
Byte_6  % Reserved
Byte_7  % Reserved(10h)
Byte_8  % CRC*


% 温度寄存器(“S”表示测量温度的正负值)
___________________________________________________________
%         BIT7  BIT6  BIT5  BIT4  BIT3  BIT2  BIT1  BIT0
LSB BYTE  2^3   2^2   2^1   2^0   2^-1  2^-2  2^-3 2^-4
MSB BYTE  S     S     S     S     S     2^6   2^5   2^4
___________________________________________________________


% TH和TL寄存器(“S”表示设定告警温度的正负值)
___________________________________________________________
BIT7  BIT6  BIT5  BIT4  BIT3  BIT2  BIT1  BIT0
S     2^6   2^5   2^4   2^3   2^2   2^1   2^0
___________________________________________________________


% 配置寄存器(R1,R0用于标识测量温度的精度)(默认12位精度: 0.0625)
___________________________________________________________
BIT7  BIT6  BIT5  BIT4  BIT3  BIT2  BIT1  BIT0
0     R1    R0    1     1     1     1     1
___________________________________________________________



############################################################
### % DS18B20数字温度计->数据格式
############################################################
%__________________________________________________________
% DS18B20温度转换(S为“0”温度为“+”， S为“1”温度为“-”)
% 它存储数据的格式以“补码”形式存放的
% 它的温度为“+”时， 它的“原码”“反码”“补码”都是一样的
% 它的温度为“-”时， 需要转换
___________________________________________________________
%         BIT7  BIT6  BIT5  BIT4  BIT3  BIT2  BIT1  BIT0
LSB BYTE  2^3   2^2   2^1   2^0   2^-1  2^-2  2^-3 2^-4
MSB BYTE  S     S     S     S     S     2^6   2^5   2^4
___________________________________________________________


### % 原码， 反码， 补码
___________________________________________________________
计算机里都是以“补码”的形式存储数据！
___________________________________________________________
最高位为符号位， “0”代表正数据， “1”代表负数，
非符号位为该数字绝对值的二进制。
“+5”原码  (0000 0101)   “-5”原码  (1000 0101)
___________________________________________________________
“+5”反码  (0000 0101)   “-5”反码  (1111 1010)
___________________________________________________________
“+5”补码  (0000 0101)   “-5”补码  (1111 1011)



############################################################
### % DS18B20 <===> ROM指令和功能指令
############################################################
### % ROM指令
%______________________________________
1   搜索ROM指令 [F0H]
    % 当系统初始化时，总线控制器通过此指令多次
    % 循环搜索ROM编码，以确认所有从机器件
2   读取ROM指令 [33H]
    % 当总线上只有一只DS18B20时才会使用此指令
    % 允许总线控制器直接读取从机序列码
3   匹配ROM指令 [55H]
    % 使总线控制器在多点总线上定位一只特定的DS18B20
4   忽略ROM指令 [CCH]
    % 可以不提供64位ROM编码就使用功能指令
5   报警ROM指令 [ECH]
    % 当总线上存在满足报警条件的从机时，该从机响应此指令
    
    
### % 功能指令
%______________________________________
scratchpad功能指令，操作它需要下面的2个步骤
1   % Initialize
2   % ROM Command
3   % Function Command
%______________________________________
1   温度转换指令  [44H]
2   写暂存器指令  [4EH]
    % 开始位置在暂存器(TH寄存器，TL寄存器，配置寄存器)
    % 初始地址为TH寄存器，以最低有效位传送
3   读暂存器指令  [BEH]
    % 读取将从地址0开始，直到（CRC）读完
4   拷贝暂存器指令 [48H]
    % 将TH,TL，配置寄存器的数据复制到EEPROM中得以保存
5   召回EEPROM指令[B8H]
    % 将TH,TL，配置寄存器的数据从EEPROM中复制到暂存器中
6   读电源模式指令 [B4H]



############################################################
### % DS18B20 <===> 读取SCRATCHPAD—RAM中的数据
############################################################
### % DS18B20它在上电的时候，还没有开始工作，读到的是它的默认值(+85度)
___________________________________________________________
% (0xbe)为scratchpad功能指令，操作它需要下面的2个步骤
1   % Initialize
2   % ROM Command
3   % DS18B20 Function
4   % 读取DS18B20上的第一个字节 
5   % 读取DS18B20上的第二个字节
ds18b20_init();                 /* % 初始化ds18b20 */
ds18b20_write_cmd(0xcc);        /* % SKIP ROM */
/* % ds18b20开始测量温度，它需要一段时间 */
ds18b20_write_cmd(0x44);        /* % convert Temperature */
delay_ms(750);                  /* % 延时 */
ds18b20_init();                 /* % 初始化ds18b20 */
ds18b20_write_dat(0xcc);        /* % SKIP ROM */
ds18b20_write_dat(0xbe);        /* % read scratchpad */
low_value = ds18b20_read_dat(); /* % read byte_0 */
hig_value = ds18b20_read_dat(); /* % read byte_1 */



############################################################
### % DS18B20 <===> 底层驱动
############################################################
// % DS18B20初始化
// 1 单片机发出至少480us的低电平脉冲信号
// 2 单片机释放总线变为高电平，持续时间为 15~60us
// 3 若有低电平出现则说明总线上有器件做出应答，将总线电平拉低60~240us,
//   告知主机器件民经做好准备
bit ds18b20_init(void)
{
    bit flag;
    DQ = 0;         /* % A点：拉低总线 */
    delay_us(500);  /* % 延时500us，(480us~960us) */
    DQ = 1;         /* % B点：释放总线 */
    delay_us(68);   /* % BM点：延时68us，等待DQ回应 */
    flag = DQ;      /* % 读DQ上的数据保存到flag */
    delay_us(500);  /* % ME点：延时500us，(480us~960us)，也可以这么写 */
                    /* % while(!DQ); 等待ds18b20释放总线 */
    return flag;   /* % 返回ds18b20的状态，“0”初始化成功，否则失败 */
}


// % 向DS18B20中写入数据
// 1 单片机直接将引脚拉低
// 2 写“1”的时候，单片机先将这个引脚拉低，拉低的时间大于“1us”，然后马上释放总线
// 3 写“0”的时候，DS18B20 会在 15us到60us之间来读取这个“0”
// 4 读写都是从最低位开始
void ds18b20_write_dat(uint8_t dat)
{
    uint8_t tmp;
    for (tmp = 0x01; tmp !=0; tmp<<=1)
    {
        DQ = 0;         /* % 单片机拉低总线 */
        delay_us(2);    /* % 延时2us */
        if ((tmp & dat) == 0)
            DQ = 0;
        else
            DQ = 1;
        delay_us(60);   /* % 延时60us，等待DS18B20来采集数据 */
        DQ = 1;         /* % 释放总线 */
    }
}


// % 读出DS18B20中的数据
// 1 单片机直接将引脚拉低
// 2 至少保持“1us”的时间，然后释放引脚
// 3 从拉低这个引脚到读取这个引脚状态，不能超过“15us”
// 4 读写都是从最低位开始
int8_t ds18b20_read_dat(void)
{
    uint8_t dat, tmp;
    for (tmp = 0x01; tmp != 0; tmp<<=1)
    {
        DQ = 0;         /* % 单片机拉低总线 */
        delay_us(2);    /* % 延时2us */
        DQ = 1;         /* % 释放总线 */
        delay_us(2);    /* % 延时2us, 等待DS18B20拉低或拉高 */
        if (DQ)         /* % 读取DQ总线上的位数据 */
            dat |= tmp;
        else
            dat &= ~tmp;
        delay_us(60);   /* % 延时60us */
    }
    return dat;
}



############################################################
### % DS18B20 <===> 温度显示基于LCD1602
### % 单总线中只有一只DS18B20
############################################################
% 单总线器件驱动程序编写流程
第一步: 初始化(对总线上的器件进行初始化)
第二步: ROM命令(指令寻找和匹配，指定待操作器件)
第三步: 功能命令(进行具体操作或传输数据)


void start_ds18b20(void)
{
    bit ack
    // % ds18b20初始化
    ack = ds18b20_init();
    if (ack == 0)
    {   // % 跳过ROM指令(ROM指令)
        ds18b20_write_dat(SKIP_ROM);
        // % 启动温度转换(功能指令)
        ds18b20_write_dat(CONVERT_T);
    }
}


read_ds18b20(uint8_t *pstr)
{
    uint8_t msb, lsb;
    bit ack
    // % ds18b20初始化
    ack = ds18b20_init();
    if (ack == 0)
    {   // % 跳过ROM指令(ROM指令)
        ds18b20_write_dat(SKIP_ROM);
        // % 读取温度暂存器(功能指令)
        ds18b20_write_dat(READ_REGISTER);
        // % 读出转换结果
        lsb = ds18b20_read_dat();
        msb = ds18b20_read_dat();
        *pstr = ((uint16_t)msb << 8) + lsb;
    }
}



uint16_t temp;                  // % 保存接收到的温度数据
uint16_t temp_int;              // % 分离温度的整数
uint16_t temp_float;            // % 分离温度的小数
uint8_t  str[];                 // % 保存数据转换成的字符串 ASCII
uint8_t  len;

start_ds18b20();
ack = read_ds18b20(&temp);
if (ack)
{
    temp_int    = temp >> 4;    // % 保留整数部分
    temp_float  = temp & 0x0f;  // % 保留小数部分
}
















