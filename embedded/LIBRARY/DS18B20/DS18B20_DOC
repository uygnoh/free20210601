############################################################
### % DS18B20数字温度计
############################################################
SCRATCHPAD(POWER-UP STATE)                      EEPROM
___________________________________________________________
Byte_0  % Temperature LSB(50h)
Byte_1  % Temperature MSB(05h)
Byte_2  % TH Register or User Byte 1*   <===>   TH Register or User Byte 1
Byte_3  % TL Register or User Byte 2*   <===>   TL Register or User Byte 2
Byte_4  % Configuration Register*       <===>   Configuration Register
Byte_5  % Reserved(FFh)
Byte_6  % Reserved
Byte_7  % Reserved(10h)
Byte_8  % CRC*
___________________________________________________________


% DS18B20温度转换(S为“0”温度为“+”， S为“1”温度为“-”)
% 它存储数据的格式以“补码”形式存放的
% 它的温度为“+”时， 它的“原码”“反码”“补码”都是一样的
% 它的温度为“-”时， 需要转换
___________________________________________________________
%         BIT7  BIT6  BIT5  BIT4  BIT3  BIT2  BIT1  BIT0
LSB BYTE  2^3   2^2   2^1   2^0   2^-1  2^-2  2^-3 2^-4
MSB BYTE  S     S     S     S     S     2^6   2^5   2^4
___________________________________________________________


% SKIP ROM [CCh]
___________________________________________________________
如果总线上只有一个DS18B20，可以选择这个ROM指令


% 读取SCRATCHPAD—RAM中的数据
% DS18B20它在上电的时候，还没有开始工作，读到的是它的默认值(+85度)
___________________________________________________________
(0xbe)为scratchpad功能指令，操作它需要下面的2个步骤
1   % Initialize
2   % ROM Command
3   % DS18B20 Function
4   % 读取DS18B20上的第一个字节 
5   % 读取DS18B20上的第二个字节
ds18b20_init();                 /* % 初始化ds18b20 */
ds18b20_write_cmd(0xcc);        /* % SKIP ROM */
/* % ds18b20开始测量温度，它需要一段时间 */
ds18b20_write_cmd(0x44);        /* % convert Temperature */
delay_ms(750);
ds18b20_init();                 /* % 初始化ds18b20 */
ds18b20_write_cmd(0xcc);        /* % SKIP ROM */
ds18b20_write_cmd(0xbe);        /* % read scratchpad */
low_value = ds18b20_read_dat(); /* % read byte_0 */
hig_value = ds18b20_read_dat(); /* % read byte_1 */



############################################################
### % 原码， 反码， 补码
############################################################
计算机里都是以“补码”的形式存储数据！
___________________________________________________________
最高位为符号位， “0”代表正数据， “1”代表负数，
非符号位为该数字绝对值的二进制。
“+5”原码  (0000 0101)   “-5”原码  (1000 0101)
___________________________________________________________
“+5”反码  (0000 0101)   “-5”反码  (1111 1010)
___________________________________________________________
“+5”补码  (0000 0101)   “-5”补码  (1111 1011)


############################################################
### % ds18b20
############################################################
1 单片机发出至少480us的低电平脉冲信号
2 单片机释放总线变为高电平，持续时间为 15~60us
3 若有低电平出现则说明总线上有器件做出应答，将总线电平拉低60~240us,
  告知主机器件民经做好准备
bit ds18b20_init(void)
{
    bit flag;
    DQ = 0;         /* % A点：拉低总线 */
    delay_us(500);  /* % 延时500us，至少480us */
    DQ = 1;         /* % B点：释放总线 */
    delay_us(68);   /* % BM点：延时68us，等待DQ回应 */
    flag = DQ;      /* % 读DQ上的数据保存到flag */
    delay_us(500);  /* % ME点：延时500us，至少480us，也可以这么写 */
                    /* % while(!DQ); ds18b20释放总线就跳循环 */
    return flag;   /* % 返回ds18b20的状态，“0”初始化成功，否则失败 */
}


1 单片机直接将引脚拉低
2 写“1”的时候，单片机先将这个引脚拉低，拉低的时间大于“1us”，然后马上释放总线
3 写“0”的时候，DS18B20 会在 15us到60us之间来读取这个“0”
4 读写都是从最低位开始
void ds18b20_write_cmd(uint8_t cmd)
{
    uint8_t tmp;
    for (tmp = 0x01; tmp !=0; tmp<<=1)
    {
        DQ = 0;         /* % 单片机拉低总线 */
        delay_us(2);    /* % 延时2us */
        if ((tmp & cmd) == 0)
            DQ = 0;
        else
            DQ = 1;
        delay_us(60);   /* % 延时60us，等待DS18B20来采集数据 */
        DQ = 1;         /* % 释放总线 */
    }
}


1 单片机直接将引脚拉低
2 至少保持“1us”的时间，然后释放引脚
3 从拉低这个引脚到读取这个引脚状态，不能超过“15us”
4 读写都是从最低位开始
int8_t ds18b20_read_dat(void)
{
    uint8_t dat, tmp;
    for (tmp = 0x01; tmp != 0; tmp<<=1)
    {
        DQ = 0;         /* % 单片机拉低总线 */
        delay_us(2);    /* % 延时2us */
        DQ = 1;         /* % 释放总线 */
        delay_us(2);    /* % 延时2us */
        if (DQ)         /* % 读取DQ总线上的位数据 */
            dat = dat|tmp;
        else
            dat = dat & (~tmp);
        delay_us(60);   /* % 延时60us */
    }
    return dat;
}



