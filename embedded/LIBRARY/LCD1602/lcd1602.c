/*******************************************************
 * LCD1602(并行8位数据接口)
 *
 *******************************************************/
#include "lcd1602.h"

int main(void)
{
    lcd1602_init();
    lcd1602_write_cmd(0x80);        /* % 给出地址指针，第一行的第1个字符位 */
    lcd1602_write_dat('y');         /* % 写入数据 */
    lcd1602_write_cmd(0x80+5);      /* % 给出地址指针,第一行第6个字符位 */
    lcd1602_write_dat('0');         /* % 显示0 */
    lcd1602_write_dat(0x30);        /* % 显示0 */
    lcd1602_write_cmd(0x80+0x40);   /* % 给出地址指针，第二行的第1个字符 */
    lcd1602_write_dat(0x38);        /* % 显示数字 8 */
    lcd1602_show_string(0,0,"hello,");
	lcd1602_show_string(4,1,"world!");
}

/*******************************************************
 * 函数名称: lcd1602_write_cmd
 * 输入参数: cmd->发送的命令
 * 输出参数: <-无
 *
 *******************************************************/
void lcd1602_write_cmd(uint8_t cmd)
{   
    RS = 0;                     /* % RS为低电平表示要写入的是命令(command) */
    RW = 0;                     /* % RW为低电平表示是写信号 */
    EN = 0;                     /* % EN为使能信号，开始为低电平 */
    P0 = cmd;                   /* % 先送入命令(command) */
    delay_ms(2);                /* % 稍作延时，等待数据稳定 */
    EN = 1;                     /* % 然后在把使能信号拉高，数据开始写入LCD1602中 */
    delay_ms(2);                /* % 稍作延时，等待数据写入完成 */
    EN = 0;                     /* % 之后再把使能信号拉低 */
    delay_ms(2);                /* % 稍作延时 */
}

/*******************************************************
 * 函数名称: lcd1602_write_dat
 * 输入参数: cmd->发送的数据
 * 输出参数: <-无
 *
 *******************************************************/
void lcd1602_write_dat(uint8_t dat)
{   
    RS = 1;                     /* % RS为低高电平表示要写入的是数据 */
    RW = 0;                     /* % RW为低电平表示是写信号 */
    EN = 0;                     /* % EN为使能信号，开始为低电平 */
    P0 = dat;                   /* % 先送人(data数据) */
    delay_ms(2);                /* % 稍作延时，等待数据稳定 */
    EN = 1;                     /* % 然后在把使能信号拉高，数据开始写入LCD1602中 */
    delay_ms(2);                /* % 稍作延时，等待数据写入完成 */
    EN = 0;                     /* % 之后再把使能信号拉低 */
    delay_ms(2);                /* % 稍作延时 */
}

/*******************************************************
 * 函数名称: lcd1602_init
 * 输入参数: ->无
 * 输出参数: <-无
 *
 *******************************************************/
void lcd1602_init(void)
{
    lcd1602_write_cmd(0x38);    /* % 显示模式设置 */
    delay_ms(5);
    lcd1602_write_cmd(0x0f);    /* % 光标显示[0x0E,光标不闪][0x0C，光标不显示] */
    delay_ms(5);
    lcd1602_write_cmd(0x0c);    /* % 显示开及光标设置 */
    delay_ms(5);
    lcd1602_write_cmd(0x06);    /* % 显示光标移动设置(地址指针自动加1) */
    delay_ms(5);
    lcd1602_write_cmd(0x01);    /* % 显示清屏 */
    delay_ms(5);
}

/*******************************************************
 * 函数名称: lcd1602_clear_all
 * 输入参数: ->无
 * 输出参数: <-无
 *
 *******************************************************/
void lcd1602_clear_all(void)
{
    lcd1602_write_cmd(0x01);
    lcd1602_write_cmd(0x80);
}

/*******************************************************
 * 函数名称: lcd1602_busy
 * 输入参数: ->无
 * 输出参数: <-(0x80_忙碌状态, 否则为空闲状态)
 *
 *******************************************************/
/* % lcd1602判断忙 */
void lcd1602_busy_check(void)
{
    uint8_t tmp = 0;
    uint8_t status = 0;
    P0 = 0xFF;          /* % 设置BYTE全部为高电平 */
    RS = 0;             /* % RS为“0”, 表示“读命令” */
    RW = 1;             /* % RW为“1”, 表示“读”*/
    delay_us(1);        /* % 稍作延时 */
    do {
        EN = 1;         /* % 拉高“EN” */
        delay_us(1);    /* % 稍作延时，等待lcd1602上的数据稳定 */
        status = P0;    /* % 读取lcd1602上的数据 */
        delay_us(1);    /* % 稍作延时 */
        EN = 0;         /* % 拉低EN */
        delay_us(1);    /* % 稍作延时 */
        tmp++;
        if (tmp > 128)
            break;
    /* % 判断BYTE端口上的数据最高位，为“1”表示忙 */
    } while (status & 0x80);
}


/*******************************************************
 * 函数名称: lcd1602_show_char
 * 输入参数: pos_x  ->行坐标
 * 输入参数: pos_y  ->列坐标
 * 输入参数: t_char ->要写入的字符
 * 输出参数: <-无
 *
 *******************************************************/
/* % set a character at the givEN position */ 
/* % 在指定坐标设置字符 (x=0~1, y=0~15) */
void lcd1602_show_char(uint8_t pos_x, uint8_t pos_y, uint8_t t_char)
{
    uint8_t addr = 0x80;        /* % lcd1602基地址 */
    pos_x &= 0x01;              /* % 行地址，共有2行; 取行地址* /
    pos_y &= 0x0f;              /* % 列地址，共有16列; 取列地址 */
    addr  |= pos_y;             /* % 获得lcd1602列地址值 */
    if (pos_x)                  /* % 判断lcd1602是第几行(0或1) */                    
        addr |= 0x40;           /* % 如果是第2行的话，加“0x40” */
    lcd1602_write_cmd(addr);    /* % lcd1602写入位置信息 */
    lcd1602_write_dat(t_char);  /* % lcd1602写入数据信息 */
}

/*******************************************************
 * 函数名称: lcd1602_show_string
 * 输入参数: pos_x  ->行坐标
 * 输入参数: pos_y  ->列坐标
 * 输入参数: *pstr  ->要写入的字符串首地址
 * 输出参数: <-无
 *
 *******************************************************/
/* % write a string from the givEN position */
/* % 从指定位置开始设置字符串 (p_x=0~1，p_y=0~15，*pstr必须是以'\0'结尾的字符串) */
void lcd1602_show_string(uint8_t pos_x, uint8_t pos_y, const uint8_t *pstr)
{
    uint8_t x, y;
    pos_x &= 0x01;
    pos_y &= 0x0f;
    /* % 最外层循环， 行(0, 1) */
    for (x = pos_x; x < 2; x++) 
    {
        /* % 内层循环， 列(0 ~ 15) */
        for (y = pos_y; (y < 16) && ((*pstr) != 0); y++)
            /* % 调用写一个字符串函数 */
            lcd1602_show_char(x, y, *pstr++);
    }
}



/*******************************************************
 * 函数名称: delay_ms
 * 输入参数: ->无
 * 输出参数: <-无
 *
 *******************************************************/
/* % 毫秒级延时子程序，  (8051, 12MHZ晶振) */
void delay_ms(uint16_t z)
{
    uint16_t x,y;
    for(x = z; x > 0; x--)
        for(y = 110; y > 0; y--);
}


/*******************************************************
 * 函数名称: IntergerToStr 整形数据转换为字符串
 * 输入参数: dat ->输入的数据类型
 * 输入参数: *str->需要处理的字符串
 * 输出参数: <-len,字符串长度
 *
 *******************************************************/
uint8_t IntergerToStr(long dat, uint8_t *str)
{
    uint8_t i = 0;          // % 字符串索引
    uint8_t len = 0;        // % 字符串长度
    uint8_t buf[6];         // % 字符串临时缓冲区和要处理的字符串长度一致
    
    if (dat < 0)
    {
        dat = -dat;        // % 如果是负数，取绝对值
        *str++ = '-';
        len++;
    }
    do {
        buf[i++] = dat%10 + '0';  // % 反着取字符串
        dat /= 10;
    } while (dat > 0);
    
    len += i;             // % 在把字符长度放入len中
    
    while (i-- > 0)       // % 在把字符串反过来 
    {
        *str++ = buf[i];
    }
    *str = '\0';          // % 字符串结束加入一个“\0”                   
    return len;          // % 返回字符串长度
}


