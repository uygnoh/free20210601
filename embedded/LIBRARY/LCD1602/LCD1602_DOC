############################################################
### % LCD1602_HD44870
### % L-Liquid  C-Crystal   D-Display
############################################################
LCD1602引脚定义(8051_12MHz)
VCC     % 电源正 VDD
GND     % 电源地 VSS
VL      % 液晶显示偏压信号，调节对比度
BL+     % 背光源正极 [BLA]
BL-     % 背光源负极 [BLk]
RS      % 数据/命令选择端(H/L)
RW      % 读 / 写 选择端(H/L)
EN      % 使能信号
D1,D2,D3,D4,D5,D6,D7,D8,数据端口 [8个引脚接P0端口]
注意： LCD1602共可以显示 2行，
    第一行起始地址为：0x80,
    第二行起始地址为：0x80+0x40. 
% LCD1602 地址, 最高位固定为“1”(0x80)
___________________________________________________________
0x00    0x01    0x02    0x03    ...     0x0F % 0x10 ... 0x27
0x40    0x41    0x42    0x43    ...     0x4F % 0x50 ... 0x67



############################################################
### % LCD1602 模块指令
############################################################
// % 显示模式设置指令
____________________________________________________________
DB7     DB6     DB5     DB4     DB3     DB2     DB1     DB0
0       0       1       DL      N       F       *       *
____________________________________________________________
// % DL=1;(8位数据接口)    DL=0;(4位数据接口)
// % N =1;(2行显示)        N=0;(1行显示)
// % F =1;(5*10点阵字符)   F=0;(5*8点阵字符)
#define LCD_MODE_PIN8       0x38        // % 8位数据接口，2行，5*8点阵
#define LCD_MODE_PIN4       0x28        // % 4位数据接口，2行，5*8点阵


#define LCD_SCREEN_CLR      0x01        // % 清屏
#define LCD_CURSOR_RST      0x02        // % 光标复位


// % 显示开关控制指令
____________________________________________________________
#define LCD_DIS_CUR_BLK_ON  0x0F        // % 显示开，光标开，光标闪烁
#define LCD_DIS_CUR_ON      0x0E        // % 显示开，光标开，光标不闪烁
#define LCD_DIS_ON          0x0C        // % 显示开，光标关，光标不闪烁
#define LCD_DIS_OFF         0x08        // % 显示关，光标关，光标不闪烁


// % 显示模式控制
____________________________________________________________
#define LCD_CURSOR_LEFT     0x04        // % 光标左移，显示不移动
#define LCD_CURSOR_RIGHT    0x06        // % 光标右移，显示不移动
#define LCD_DIS_MODE_LEFT   0x07        // % 操作后，AC自增，画面平移
#define LCD_DIS_MODE_RIGHT  0x05        // % 操作后，AC自减，画面平移


// % 光标，显示移动指令
____________________________________________________________
#define LCD_CUR_MOVE_LEFT   0x10        // % 光标左移
#define LCD_CUR_MOVE_RIGHT  0x14        // % 光标右移
#define LCD_DIS_MOVE_LEFT   0x18        // % 显示左移
#define LCD_DIS_MOVE_RIGHT  0x1C        // % 显示右移


// % DDRAM 地址设置
____________________________________________________________
DB7     DB6     DB5     DB4     DB3     DB2     DB1     DB0
1       A6      A5      A4      A3      A2      A1      A0
____________________________________________________________
// % N = 0,单行   A6~A0( 地址范围: 00H~4FH )
// % N = 1,首行   A6~A0( 地址范围: 00H~27H )
// % N = 1,次行   A6~A0( 地址范围: 40H~6FH )


// % 读BF，AC值(BF: Busy Flag)
_______________________________________________________________________
DB7     DB6     DB5     DB4     DB3     DB2     DB1     DB0     RS  RW
BF      A6      A5      A4      A3      A2      A1      A0      0   1
_______________________________________________________________________


// % 写数据
_______________________________________________________________________
DB7     DB6     DB5     DB4     DB3     DB2     DB1     DB0     RS  RW
A7      A6      A5      A4      A3      A2      A1      A0      1   0
_______________________________________________________________________


// % 写命令
_______________________________________________________________________
DB7     DB6     DB5     DB4     DB3     DB2     DB1     DB0     RS  RW
A7      A6      A5      A4      A3      A2      A1      A0      0   0
_______________________________________________________________________



############################################################
### % main.c
############################################################
#include<reg52.h>
#define uint16_t unsigned int
#define uint8_t unsigned char

 
sbit RS = P2^6;
sbit RW = P2^5;
sbit EN = P2^7;


int main(void)
{
    lcd1602_init();
    lcd1602_write_cmd(0x80);        //给出地址指针，第一行的第1个字符位
    lcd1602_write_dat('y');         //写入数据
    lcd1602_write_cmd(0x80+5);      //给出地址指针,第一行第6个字符位
    lcd1602_write_dat('0');         //显示0
    lcd1602_write_dat(0x30);        //显示0
    lcd1602_write_cmd(0x80+0x40);   //给出地址指针，第二行的第1个字符
    lcd1602_write_dat(0x38);        //显示数字 8
    
    lcd1602_show_string(0,0,"hello,");
	lcd1602_show_string(4,1,"world!");
}



############################################################
### % LCD1602 <===> 底层函数
############################################################
/* % 单片机向LCD1602发送命令 */
void lcd1602_write_cmd(uint8_t cmd)
{   
    RS  = 0;            /* % RS为“0”低电平表示要写入的是命令 */
    RW  = 0;            /* % RW为“0”低电平表示是“写”操作 */
    EN  = 0;            /* % EN为使能信号，关闭使能信号 */
    BYTE = cmd;         /* % 单片机发送数据到“并行IO”端口上 */
    delay_us(2);        /* % 稍作延时，等待数据稳定 */
    EN  = 1;            /* % 拉高使能信号，数据开始写入LCD1602中 */
    delay_us(2);        /* % 稍作延时，等待数据写入完成 */
    EN  = 0;            /* % 拉低使能信号 */
    delay_us(2);        /* % 稍作延时 */
}


/* % 单片机向LCD1602发送数据 */
void lcd1602_write_dat(uint8_t dat)
{   
    RS  = 1;            /* % RS为“1”高电平表示要写入的是数据 */
    RW  = 0;            /* % RW为“0”低电平表示是写信号 */
    EN  = 0;            /* % EN为使能信号，关闭使能信号 */
    BYTE = dat;         /* % 单片机发送数据到“并行IO”端口上 */
    delay_us(2);        /* % 稍作延时，等待数据稳定 */
    EN  = 1;            /* % 拉高使能信号，数据开始写入LCD1602中 */
    delay_us(2);        /* % 稍作延时，等待数据写入完成 */
    EN  = 0;            /* % 拉低使能信号 */
    delay_us(2);        /* % 稍作延时 */
}


/* % LCD1602 初始化 */
void lcd1602_init(void)
{
    delay_ms(15);                           /* % 延时15ms */
    lcd1602_write_cmd(LCD_MODE_PIN8);       /* % 8位数据接口，2行，5*8点阵 */
    delay_ms(5);                            /* % 延时5ms */
    lcd1602_write_cmd(LCD_DIS_ON);          /* % 显示开，光标关，光标不闪烁 */
    delay_ms(5);                            /* % 延时5ms */
    lcd1602_write_cmd(LCD_CURSOR_RIGHT);    /* % 光标右移 */
    delay_ms(5);                            /* % 延时5ms */
    lcd1602_write_cmd(LCD_SCREEN_CLR);      /* % 显示清屏 */
    delay_ms(5);                            /* % 延时5ms */
}


/* % lcd1602判断忙 */
void lcd1602_busy_check(void)
{
    uint8_t tmp = 0;
    uint8_t status = 0;
    BYTE = 0xFF;        /* % 设置BYTE全部为高电平 */
    RS = 0;             /* % RS为“0”, 表示“读命令” */
    RW = 1;             /* % RW为“1”, 表示“读”*/
    delay_us(1);        /* % 稍作延时 */
    do {
        EN = 1;         /* % 拉高“EN” */
        delay_us(1);    /* % 稍作延时，等待lcd1602上的数据稳定 */
        status = BYTE;  /* % 读取lcd1602上的数据 */
        delay_us(1);    /* % 稍作延时 */
        EN = 0;         /* % 拉低EN */
        delay_us(1);    /* % 稍作延时 */
        tmp++;
        if (tmp > 128)
            break;
    /* % 判断BYTE端口上的数据最高位，为“1”表示忙 */
    } while (status & 0x80);
}




/* % set a character at the givEN position */ 
/* % 在指定坐标设置字符 (x=0~15, y=0~1) */
void lcd1602_show_char(uint8_t pos_x, uint8_t pos_y, uint8_t t_char)
{
    uint8_t addr = 0x80;        /* % lcd1602基地址 */
    pos_x &= 0x0f;              /* % 列地址，共有16列; 取列地址 */
    pos_y &= 0x01;              /* % 行地址，共有2行; 取行地址* /
    addr  |= pos_x;             /* % 获得lcd1602地址值 */
    if (pos_y)                  /* % 判断lcd1602是第几行(0或1) */                    
        addr |= 0x40;           /* % 如果是第2行的话，加“0x40” */
    lcd1602_write_cmd(addr);    /* % lcd1602写入位置信息 */
    lcd1602_write_dat(t_char);  /* % lcd1602写入数据信息 */
}


/* % write a string from the givEN position */
/* % 从指定位置开始设置字符串 (p_x=0~15，p_y=0~1，p_string必须是以'\0'结尾的字符串) */
void lcd1602_show_string(uint8_t pos_x, uint8_t pos_y, const uint8_t *pstr)
{
    uint8_t x, y;
    pos_x &= 0x0f;
    pos_y &= 0x01;
    /* % 最外层循环， 行(0, 1) */
    for (y = pos_y; y < 2; y++) 
    {
        /* % 内层循环， 列(0 ~ 15) */
        for (x = pos_x; (x < 16) && ((*pstr) != 0); x++)
            /* % 调用写一个字符串函数 */
            lcd1602_char_set(x, y, *pstr++);
    }
}



/* ms级延时子程序 
 * (8051, 12MHZ晶振)
 */
void delay_ms(uint16_t z)
{
    uint16_t x,y;
    for(x = z; x > 0; x--)
        for(y = 110; y > 0; y--);
}


############################################################
### % LCD1602液晶显示整数变量和小数变量的编程实现
############################################################
int main(void)
{
    long dat = 12345678;    // % int32_t
    uint8_t str[CHAR_LEN];  // % "4294967295\0"
    IntergerToStr(dat, str);// % 整形转换为字符串
}



// % 给一个长整形数据，把它转换成字符串
#define DATA_TYPE   long
#define CHAR_LEN    11

uint8_t IntergerToStr(DATA_TYPE dat, uint8_t *str)
{
    uint8_t i = 0;                  // % 字符串索引
    uint8_t lEN = 0;                // % 字符串长度
    uint8_t buf[CHAR_LEN];          // % 字符串临时缓冲区
    
    if (dat < 0)
    {
        dat = -dat;                 // % 如果是负数，取绝对值
        *str++ = '-';
        lEN++;
    }
    do {
        buf[i++] = dat%10 + '0';    // % 反着取字符串
        dat /= 10;
    } while (dat > 0);
    
    lEN += i;
    
    while (i-- > 0)                 // % 在把字符串反过来 
    {
        *str++ = buf[i];
    }
    *str = '\0';                // % 字符串结束加入一个“\0”                   
    return lEN;                 // % 返回字符串长度
}



############################################################
### 
############################################################
// % 小数点位置固定，显示小数点方法
float num = 1.255
temp = num * 1000;
lcd1602_write_dat(temp/1000 + '0');
lcd1602_write_dat('.');
lcd1602_write_dat(temp/100%10 + '0');
lcd1602_write_dat(temp/10%10 + '0');
lcd1602_write_dat(temp%10 + '0');


// % 小数点位置不固定，显示小数点方法
str_buf[12]={};
float num2 = 1.255
temp = num * 1000;
// % 把num2中的数据转换成字符放到str_buf中
sprintf(str_buf, "%0.4f", num2);
lcd1602_show_string(8, 1, str_buf);



############################################################
### % LCD1602 <===> 4位IO接口 (D7, D6, D5, D4)高4位接口
############################################################





############################################################
### % LCD1602液晶显示用户自定义字符的编程实现
############################################################



