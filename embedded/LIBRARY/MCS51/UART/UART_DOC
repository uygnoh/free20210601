############################################################
### % uart查询方式 
############################################################
// % uart查询方式 
// % 4800bps (11.0592MHz)
// % 1位起始位， 1位停止位， 8位数据位， 共10位数据
void uart_init(void)
{
    PCON &= 0x7F;   // % 波特率不倍速
    SCON  = 0x50;   // % 8位数据，可变波特率
    TMOD &= 0x0F;   // % 清除定时器“1”模式位
    TMOD |= 0x20;   // % 设定定时器1为8位自动重装方式
    TL1   = 0xFA;   // % 设定定时初值
    TH1   = 0xFA;   // % 设定定时器重装值
    ET1   = 0;      // % 禁止定时器1中断
    TR1   = 1;      // % 启动定时器1
}


// % 发送一帧数据
void send_byte(uint8_t dat)
{
    SBUF = dat;
    while(!TI)
        TI = 0;
}


// % 发送一串数据
void send_string(uint8_t *pstr)
{
    while (*pstr != '\0')
    {
        send_byte(*pstr++);
    }
}


int main(void)
{
    while (1)
    {
        //send_byte('8');
        //send_byte('\r');
        //send_byte('\n');
        //delay_ms(1000);
        send_string("Hello world!");
    }
}



############################################################
### % printf重定向(基于Keil IDE)
############################################################
// % C51 Development Tools
#include <stdio.h>

char putchar(char c)
{
    send_byte(c);
    return(c);
}

printf("Hello world!\r\n");




############################################################
### % 串行口从上位机接收一帧数据的编程实现方法
############################################################
// % uart中断方式接收一帧数据， 并且加“1”
// % 再用中断方式发送出去
uint8_t rx_dat;
uint8_t tx_dat;
uint8_t rx_flag = 0;

 
// % 4800bps (11.0592MHz)
// % 1位起始位， 1位停止位， 8位数据位， 共10位数据
void uart_init(void)
{
    PCON &= 0x7F;   // % 波特率不倍速
    SCON  = 0x50;   // % 8位数据，可变波特率
    TMOD &= 0x0F;   // % 清除定时器“1”模式位
    TMOD |= 0x20;   // % 设定定时器1为8位自动重装方式
    TL1   = 0xFA;   // % 设定定时初值
    TH1   = 0xFA;   // % 设定定时器重装值
    ET1   = 0;      // % 禁止定时器1中断
    ES    = 1;      // % 串行口中断打开
    EA    = 1;      // % 打开中断总开关
    TR1   = 1;      // % 启动定时器1
}


// % 发送一帧数据
void send_byte(uint8_t dat)
{
    SBUF = dat;
    while(!TI)
        TI = 0;
}


// % 发送一串数据
void send_string(uint8_t *pstr)
{
    while (*pstr != '\0')
    {
        send_byte(*pstr++);
    }
}

// % 串行口中断服务程序
void UART_IST(void) interrupt 4
{
    if (RI)
    {
        RI     = 0;
        rx_dat = SBUF;
        // % 使用查询方式的话，使用rx_flag = 1;
        rx_flag = 1;
        // % 使用中断方式话，使用下面这两条语句
        //rx_dat = rx_dat + 1;
        //SBUF   = rx_dat;
    }
    if (TI)
    {
        TI     = 0;
    }
}

// % 使用中断方式
int main(void)
{
    while (1)
    {   
    }
}


// % 使用查询方式
int main(void)
{
    while (1)
    {   // % 使用查询方式，把接收到的数据加一， 并发送出去
        if (rx_flag == 1)
        {
            rx_flag = 0;
            rx_dat = rx_dat + 1;
            send_byte(rx_dat);
        }
    }
}




// % 上位机发送 0x01, 打开LED
// % 上位机发送 0x00, 关闭LED
int main(void)
{
    while (1)
    {   // % 使用查询方式
        if (rx_flag == 1)
        {
            rx_flag = 0;
            switch (rx_dat)
            {
                case 0x00: LED = 1; // % LED灭
                case 0x01: LED = 0; // % LED亮
                default: break;
            }
        }
    }
}




############################################################
### % 单片机串行口从上位机接收一串数据的编程实现
### % 只能接收回定长度的数据
############################################################
// % 接收缓冲区，接收到的数据放到此数组中
uint8_t rx_buf[10];
// % 接收到8字节数据，rx_flag=1
uint8_t rx_flag;


// % 4800bps (11.0592MHz)
// % 1位起始位， 1位停止位， 8位数据位， 共10位数据
void uart_init(void)
{
    PCON &= 0x7F;   // % 波特率不倍速
    SCON  = 0x50;   // % 8位数据，可变波特率
    TMOD &= 0x0F;   // % 清除定时器“1”模式位
    TMOD |= 0x20;   // % 设定定时器1为8位自动重装方式
    TL1   = 0xFA;   // % 设定定时初值
    TH1   = 0xFA;   // % 设定定时器重装值
    ET1   = 0;      // % 禁止定时器1中断
    ES    = 1;      // % 串行口中断打开
    EA    = 1;      // % 打开中断总开关
    TR1   = 1;      // % 启动定时器1
}


// % 发送一帧数据
void send_byte(uint8_t dat)
{
    SBUF = dat;
    while(!TI)
        TI = 0;
}


// % 发送一串数据
void send_string(uint8_t *pstr)
{
    while (*pstr != '\0')
    {
        send_byte(*pstr++);
    }
}

// % 串行口中断服务程序
void UART_IST(void) interrupt 4
{
    static uint8_t rx_cnt = 0;
    if (RI)
    {
        RI = 0;
        rx_bur[rx_cnt] = SBUF;
        rx_cnt++;
        if (rx_cnt == 8)
        {
            rx_flag = 1;
            rx_cnt  = 0;
        }
    }
}


int main(void)
{
    printf("Wait for Serial communication Test Start ...");
    printf("Please Send a String of Data:");
    while (1)
    {
        rx_flag = 0;
        send_string(rx_buf);
    }
}



############################################################
### % 单片机串行口从上位机接收一串数据的编程实现
### % 可以接收不定长度的数据
### % 增加一个数据的结束符“0x0D”来实现一串数据的结束
############################################################
#define MAX_RX_VAL  10

// % 接收缓冲区，接收到的数据放到此数组中
uint8_t rx_buf[MAX_RX_VAL];

// % 接收到8字节数据，rx_flag=1
uint8_t rx_flag;

// % 接收到字节数据实际的长度
uint8_t rx_len;

// % 4800bps (11.0592MHz)
// % 1位起始位， 1位停止位， 8位数据位， 共10位数据
void uart_init(void)
{
    PCON &= 0x7F;   // % 波特率不倍速
    SCON  = 0x50;   // % 8位数据，可变波特率
    TMOD &= 0x0F;   // % 清除定时器“1”模式位
    TMOD |= 0x20;   // % 设定定时器1为8位自动重装方式
    TL1   = 0xFA;   // % 设定定时初值
    TH1   = 0xFA;   // % 设定定时器重装值
    ET1   = 0;      // % 禁止定时器1中断
    ES    = 1;      // % 串行口中断打开
    EA    = 1;      // % 打开中断总开关
    TR1   = 1;      // % 启动定时器1
}


// % 发送一帧数据
void send_byte(uint8_t dat)
{
    SBUF = dat;
    while(!TI)
        TI = 0;
}


// % 发送一串数据
void send_string(uint8_t *pstr)
{
    while (*pstr != '\0')
    {
        send_byte(*pstr++);
    }
}

// % 串行口中断服务程序
void UART_IST(void) interrupt 4
{
    static uint8_t rx_cnt = 0;
    uint8_t temp;
    
    // % 
    if (RI)
    {
        RI = 0;
        temp = SBUF;
        // % 如果接收的不是回车符“0x0D”, 则继续接收数据
        if (temp != 0x0D)
        {
            rx_buf[rx_cnt] = temp;
            rx_cnt++;
            if (rx_cnt > MAX_RX_VAL)
            {
                rx_cnt = MAX_RX_VAL;
            }
        }
        // % 如果接收的是回车符“0x0D”, 则说明接收数据已完成
        else 
        {
            // % 接收数据已完成， 能知主程序处理，把标志位置“1”
            rx_flag = 1;
            // % 把接收到数据的长度给“rx_len”
            rx_len = rx_cnt;
            // % 清除rx_cnt， 方便下一次数据的接收
            rx_cnt = 0;
        }
    }

}


int main(void)
{
    uint8_t i;
    printf("Wait for Serial communication Test Start ...\r\n");
    printf("Please Send a String of Data:\r\n");
    while (1)
    {
        if (rx_flag == 1)
        {
            rx_flag = 0;
            for (i = 0; i < rx_len; i++)
            {
                send_byte(rx_buf[i]);
            }
        }
    }
}




############################################################
### % 单片机串行口定时中断实现超时接收一串数据的编程实现
############################################################
% 上位机向下位机发送一串位数据，也没有固定长度，也没有结束标志符
1 根据接收时间来判断一帧数据的长度
2 如果接收时间大于一定的时间还没有新的数据来
3 那么就表示这一帧数据接收完成

// % 定义接收数据缓冲区最在值
#define MAX_RX_NUM  10

// % 定义接收最大时间为3个毫秒
#define MAX_RX_TIME 3

// % 启动软件定时器
uint8_t start_timer = 0;
// % 每接收到一帧数据后，就开始计时
uint8_t rx_timer_cnt;

// % 定义一包数据接收完成标志
uint8_t rx_flag;

// % 定义一个接收缓冲区
uint8_t rx_buf[MAX_RX_NUM];

// % 定义接收字符计数变量
uint8_t rx_cnt = 0;


// % 9600bps (11.0592MHz)
// % 1位起始位， 1位停止位， 8位数据位， 共10位数据
// % 使用定时器1，做为串行口的波特率发生器
void uart_init(void)
{
    PCON &= 0x7F;   // % 波特率不倍速
    SCON  = 0x50;   // % 8位数据，可变波特率
    TMOD &= 0x0F;   // % 清除定时器“1”模式位
    TMOD |= 0x20;   // % 设定定时器1为8位自动重装方式
    TL1   = 0xFD;   // % 设定定时初值
    TH1   = 0xFD;   // % 设定定时器重装值
    ET1   = 0;      // % 禁止定时器1中断
    ES    = 1;      // % 串行口中断打开
    TR1   = 1;      // % 启动定时器1
}
// % 串行口中断服务程序
void UART_ISR(void) interrupt 4
{
    if (RI)
    {
        RI = 0;
        // 1 % 每接收一帧数据时，打开软件计数器，去计数
        start_timer = 1;
        // % 如果rx_cnt的值小于数据缓冲区的最大值
        // % 把接收到的数据放入rx_buf[]数据缓冲区中
        if (rx_cnt < MAX_RX_NUM)
        {   // 2 % 接收到数据存储到数据缓冲区，注意缓冲区的大小范围
            rx_buf[rx_cnt] = SBUF;
            rx_cnt++;
        }
        // % 否则，超过了缓冲区中最大的值，就不在接收了
        else
        {
            rx_cnt = MAX_RX_NUM;
        }
        
        // 3 % 每接收一帧数据，记得把软件定时计数清零，相当于喂狗
        // 3 % 虽然我们在这边把它清零了，但是在定时中断里面会不断的累加
        rx_timer_cnt = 0;
    }
    if (TI)
    {
        TI = 0;
    }
}


// % 定时器0，16位的定时方式
void timer0_init(void)
{
    TMOD &= 0xF0;   // % 设置定时器模式
    TMOD |= 0x01;   // % 设置定时器模式
    TL0   = 0x66;   // % 设置定时初值
    TH0   = 0xFC;   // % 设置定时初值
    TF0   = 0;      // % 清除TF0标志
    ET0   = 1;      // % 打开定时器0中断
    TR0   = 1;      // % 定时器0开始计时
}
// % 定时器0中断服务程序
void TIMER0_ISR(void) interrupt 1
{
    TR0   = 0;      // % 关闭定时器0
    // % 如果打开了软件定时器
    if (start_timer == 1)
    {   // 1 % 累加定时时间计数器
        rx_timer_cnt++;
        // 2 % 判断定时时间是否超过了设定的的最大阈值，
        //   % 如果超过了，则说明等待一段时间后没有新的数据到来
        //   % 我们判断一包数据接收完成
        if (rx_timer_cnt > MAX_RX_TIME)
        {
            // % 软件定时时清零
            rx_timer_cnt = 0;
            // % 数据缓冲区计数个清零
            rx_cnt = 0;
            // % 接收标志置“1”
            rx_flag = 1;
        }
    }
    TL0   = 0x66;   // % 设置定时初值
    TH0   = 0xFC;   // % 设置定时初值
    TR0   = 1;      // % 打开定时器1
}


// % 发送一帧数据
void send_byte(uint8_t dat)
{
    SBUF = dat;
    while(!TI)
        TI = 0;
}
// % 发送一串数据
void send_string(uint8_t *pstr)
{
    while (*pstr != '\0')
        send_byte(*pstr++);
}


void clr_rx_buf(uint8_t *pbuf)
{
    uint8_t i;
    for (i = 0; i < MAX_RX_NUM; i++)
        rx_buf[i] = 0;
}


int main(void)
{
    timer0_init();
    uart_init();
    EA = 1;         // % 打开中断总开关
    printf("Wait for Serial communication Test Start ...\r\n");
    printf("Please Send a String of Data:\r\n");
    while (1)
    {
        if (rx_flag)
        {
            rx_flag = 0;
            start_timer = 0;        // % 关闭软件定时器
            send_string(rx_buf);    // % 处理数据
            clr_rx_buf(rx_buf);     // % 清除缓冲区
        }
    }
}














































############################################################
### % uart中断方式发送一帧数据
############################################################
// % uart中断方式
// % 9600bps (11.0592MHz)
// % 1位起始位， 1位停止位， 8位数据位， 共10位数据
void uart_init(void)
{
    PCON &= 0x7F;   // % 波特率不倍速
    SCON  = 0x50;   // % 8位数据，可变波特率
    TMOD &= 0x0F;   // % 清除定时器“1”模式位
    TMOD |= 0x20;   // % 设定定时器1为8位自动重装方式
    TL1   = 0xFD;   // % 设定定时初值
    TH1   = 0xFD;   // % 设定定时器重装值
    ET1   = 0;      // % 禁止定时器1中断
    ES    = 1;      // % 打开串行口中断
    TR1   = 1;      // % 启动定时器1
    EA    = 1;      // % 打开总中断
}

// % 串口中断服务程序
void UART_ISR(void) interrupt 4
{
    if (TI)
    {
        TI = 0;
    }
}


int main(void)
{
    uart_init();
    while (1)
    {
        SBUF = 0x88;
        delay_ms(2000);
    }
}



