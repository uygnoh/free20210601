############################################################
### % DS1302
############################################################
% DS1302是美国DALLAS公司推出的一种高性能，低功耗的实时时钟芯片。
1 % 附加“31”字节静态RAM
2 % 采用SPI三线接口与CPU进行通信
3 % 可提供秒，分， 时， 日，星期，月， 年
4 % 一个月小于“31”天时可以自动高速，且具有闰年补偿功能
4 % 工作电压为： 2.5~5.5V
5 % 采用双电源供电(主电源和备用电源)



############################################################
### % DS1302引脚功能
############################################################
Pin_8   Vcc1        % 备用电池端
Pin_1   Vcc2        % 5V电源。 当 “Vcc2 > Vcc1+0.2”时，由Vcc2向
                    % DS1302供电。“Vcc2 < Vcc1”时，由Vcc1向DS1302供电                    
Pin_7   SCLK        % 串行时钟，输入
Pin_6   SDA         % 数据输入输出端口
Pin_5   CE/RST      % 复位引脚
Pin_4   GND         % 地
Pin_3   x2          % 外接晶振引脚
Pin_2   x1          % 外接晶振引脚(32.768KHz)



############################################################
### % DS1302控制字
############################################################
________________________________________________
7     6        5   4   3   2   1       0
1   RAM/CK     A4  A3  A2  A1  A0    RD/WR
________________________________________________
bit7    % 最高有效位，必须为“1”
bit6    % 为“0”表示存取日历时钟数据，为“1”表示存取RAM数据
5:1     % 指示操作单元的地址
bit0    % 为“0”表示要进行写操作，为“1”表示要进行读操作

% 读数据，下降沿
读数据进在紧跟“8”位控制字指令后的下一个SCLK脉冲的下降沿，读出
DS1302中的数据，读出的数据是从最低位到最高位。
% 写数据，上升沿
控制字总是从最低位开始输出。在控制字指令输入后的下一个SCLK时钟的
上升沿时，数据被写入DS1320，数据输入也是从最低位开始。



############################################################
### % 8051单机(12MHz)
############################################################
#include <reg51.h>
#include <intrins.h>
sbit DS1302_IO  = P3^3
sbit SCLK       = P3^4
sbit CE         = P3^5


// % DS1302读寄存器指令地址
uchar code read_rtc_cmd[7] = {0x81, 0x83, 0x85, 0x87, 0x89, 0x8b, 0x8d}; 
// % DS1302写寄存器指令地址
uchar code write_rtc_cmd[7] = {0x80, 0x82, 0x84, 0x86, 0x88, 0x8a, 0x8c};

 
// % DS1302时钟初始化: 2013年1月1日星期二12点00分00秒
// % 存储顺序是: [秒-分-时-日-月-周-年], 存储格式是用BCD码
uchar ds1302_time[7] = {0, 0, 0x12, 0x01, 0x01, 0x02, 0x13};


// % 向DS1302写入一个字节数据
// % dat是BCD码格式， cmd是一个命令字节
void ds1302_write(uint8_t cmd, uint8_t dat)
{
    CE   = 0;           // % 初始化“CE”为低“0”
    delay_us(1);        // % 稍作延时
    SCLK = 0;           // % 初始化“SCLK”为低“0”
    delay_us(1);        // % 稍作延时
    CE   = 1;           // % 再把“CE”拉高，使能DS1302芯片
    delay_us(1);        // % 稍作延时
    ds1302_write_byte(cmd);
    ds1302_write_byte(dat);
    CE   = 0;           // % 先把“CE”拉低,完成一次操作
}


// % 从DS1302中读出一个字节的数据
// % 读出的“dat”是BCD码格式
uint8_t ds1302_read(uint8_t cmd)
{
    uint8_t dat;
    
    CE   = 0;           // % 初始化“CE”为低“0”
    delay_us(1);        // % 稍作延时
    SCLK = 0;           // % 初始化“SCLK”为低“0”
    delay_us(1);        // % 稍作延时
    CE   = 1;           // % 再把“CE”拉高，使能DS1302芯片
    delay_us(1);        // % 稍作延时
    ds1302_write_byte(cmd);
    dat = ds1302_write_byte();
    CE   = 0;           // % 先把“CE”拉低,完成一次操作
    
    return dat;
}


// % DS1302初始化，写入定义的时间信息
void ds1302_init(void)
{
    uint8_t i;
    
    ds1302_write(0x8E, 0x00)    // % 关闭写保护位
    for (i = 0; i < 7; i++)
    {
        ds1302_write(write_rtc_cmd[i], ds1302_time[i]);
    }
    ds1302_write(0x8E, 0x80)    // % 打开写保护位
}


// % DS1302读出时间，放入ds1302_time[i]中
void ds1302_read_time(void)
{
    uint8_t i;
    
    for (i = 0; i < 7; i++)
    {
        ds1302_time[i] = ds1302_read(read_rtc_cmd[i]);
    }
}




############################################################
### % DS1302 <===> spi.c
############################################################
// % 向DS1302写入一个字节， 上升沿写入
void ds1302_write_byte(uint8_t dat)
{
    uint8_t i;
    
    for (i = 0; i < 8; i++) // % 数据从最低位开始传送
    {                       // % 单片机在时钟的下降沿要把数据先准备好
        DS1302_IO = dat & 0x01; // % 把“dat”的最低位放入“DS1302_IO”端口上
        dat >>= 1;          // % 将“dat”向右移“1”位
        SCLK = 1;           // % DS1302在时钟的上升沿采样，单片机把数据输出到总线上
        delay_us(1);        // % 稍作延时
        SCLK = 0;           // % 单片机在时钟的下降沿要把数据先准备好
        delay_us(1);        // % 稍作延时

    }
}


// % 向DS1302中读取一个字节，使用移位的方法
uint8_t ds1302_read_byte(void)
{
    uint8_t tmp;
    uint8_t dat = 0;
    
    for (tmp = 0x01; tmp != 0; tmp<<=1)
    {                       // % 数据从最低位开始传送
        if (DS1302_IO != 0) // % 判断“DS1302_IO”端口上的数据是“0”还是“1”
            dat |= tmp;     // % 为“1”则把“tmp”中的数据存储到“dat”中
        SCLK = 1;           // % 单片机在时钟的上升沿采样，DS1302把数据输出到总线上
        delay_us(1);        // % 稍作延时
        SCLK = 0;           // % DS1302在时钟的下降沿要把数据准备好
        delay_us(1);        // % 稍作延时
    }
    
    return dat;
}



############################################################
### % LCD1602_DISPLAY
############################################################
void lcd1602_display(void)
{
    uint8_t str[16];
    
    str[0]  = 'D';
    str[1]  = 'A';
    str[2]  = 'T';
    str[3]  = 'E';
    str[4]  = ':';
    str[5]  = '2';
    str[6]  = '0';
    str[7]  = (ds1302_time[6] >> 4) + '0';   // % 年
    str[8]  = (ds1302_time[6] & 0x0F) + '0';
    str[9]  = '-';
    str[10] = (ds1302_time[4] >> 4) + '0';  // % 月
    str[11] = (ds1302_time[4] & 0x0F) + '0';
    str[12] = '-';
    str[13] = (ds1302_time[3] >> 4) + '0';  // % 日
    str[14] = (ds1302_time[3] & 0x0F) + '0';
    str[15] = '\0';                         // % 字符串结束符
    lcd1602_string_set(0, 0, str);
    
    str[0]  = 'T';
    str[1]  = 'I';
    str[2]  = 'M';
    str[3]  = 'E';
    str[4]  = ':';
    str[5]  = (ds1302_time[2] >> 4) + '0';   // % 小时
    str[6]  = (ds1302_time[2] & 0x0F) + '0';
    str[7]  = ':';
    str[8]  = (ds1302_time[1] >> 4) + '0';  // % 分钟
    str[9]  = (ds1302_time[1] & 0x0F) + '0';
    str[10] = ':';
    str[11] = (ds1302_time[0] >> 4) + '0';  // % 秒
    str[12] = (ds1302_time[0] & 0x0F) + '0';
    str[13] = ' ';
    str[14] = ((ds1302_time[5] - 1) & 0x0F) + '0';// % 周
    str[15] = '\0';                         // % 字符串结束符
    lcd1602_string_set(0, 1, str);
}




############################################################
### % DS1302 <===> Burst模式
############################################################
% “Burst”模式，多字节读写方式
在此模式下，最先“8”个时钟/日历寄存器可以从地址“0”的第“0”位开始连续读或写。










