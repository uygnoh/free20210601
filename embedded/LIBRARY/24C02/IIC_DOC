############################################################
### % IIC <===> 芯片与芯片之间通讯
############################################################
1 标准模式  100Kb/s
2 快速模式  400Kb/s
3 高速模式  3.4Mb/s



############################################################
### % 24C02 <===> 引脚
############################################################
A0, A1, A2      % 器件地址选择
SDA             % 串行数据/地址
SCL             % 串行时钟
WP              % 写保护
Vcc             % +1.8V~6.0V
Vss             % 地




############################################################
### % 24C02 <===> 信号
############################################################
0 数据位的有效性规定
// % IIC总线进行数据传送时，时钟信号为高电平期间，数据线上的数据必须保持稳定
// % 只有在时钟线上的信号为低电平期间，数据线上的高电平或低电平才允许变化。


1 数据传送格式
// % 每一个字节保证是“8”位长度
// % 数据传送时，先传送最高位(MSB)
// % 每一个被传送的字节后面都必须跟随一位应答位(即一帧共有9位)


2 应答位
// % 主机发送，由从机发送应答信号
// % 从机发送，由主机发送应答信号



############################################################
### % IIC <===> 底层基本时序
############################################################
// % 起始状态：当时钟线“SCL”为高电平时，数据线“SDA”出现高电平到低电平
// % 跳变时，标志IIC总线传输数据开始。由主机发出。
void iic_start_signal(void)
{
    IIC_SCL = 1;                // % 总线空闲，SCL为高
    IIC_SDA = 1;                // % 总线空闲，SDA为高
    delay_us(5);                // % SCL保持4.7us之后，
    IIC_SDA = 0;                // % 拉低SDA产生下降沿，产生起始信号。
    delay_us(5);                // % SDA保持4.7us之后，
    IIC_SCL = 0;                // % 拉低SCL产生下降沿，告诉从机开始传送数据了
}



// % 高位在前，低位在后
// % 向24C02中写入一个字节 
// % 返回ack状态
BIT iic_write_byte(uint8_t dat)
{
    uint8_t temp;
    BIT ack;                    // % 定义“从机”的ack位
    
    for (temp = 0x80; temp != 0; temp >>= 1)
    {                            // % 先传入最高位(MSB)
        if ((temp & dat) == 0)  // % 判断当前位为“0”的话写入“0”
            IIC_SDA = 0;        // % 否则向当前位写入“1”
        else
            IIC_SDA = 1;
        delay_us(5);            // % 延时最小要4us，保持SCL为低电平
        IIC_SCL = 1;            // % 拉高SCL，“器件24C02”读总线上的数据
        delay_us(5);            // % 延时最小要4us，保持SCL为高
        IIC_SCL = 0;            // % 拉低SCL
    }
    
    ack = iic_ack_signal();
    return(ack);
}



// % 高位在前，低位在后
// % 从I2C总线上读一个字节
int8_t iic_read_byte()
{
    uint8_t temp;
    uint8_t dat = 0;
    IIC_SDA = 1;                // % 主机释放总线，为接下来的数据作准备
    for (temp = 0x80; temp != 0; temp >>= 1)
    {                           // % 先传入最高位(MSB)，从最高位开始读
        delay_us(5);            // % 延时最小要4us，保持SCL为低电平
        IIC_SCL = 1;            // % 拉高SCL，“主机”读数据位
        if (IIC_SDA == 1)       // % 判断当前位为“1”的话
            dat |= temp;        // % temp中的值保存到“dat”中
        else
            dat &= ~temp;
        delay_us(5);            // % 延时最小要4us，保持SCL为高
        IIC_SCL = 0;            // % 拉低SCL, 为下一次数据传输作准备
    }
    return(dat);
}



// % “主机”发送ack位
void host_send_ack(BIT ack)
{
    IIC_SDA = ack;
    delay_us(5);            // % 延时最小要4us，保持SCL为低电平
    IIC_SCL = 1;            // % 拉高SCL，“主机”发送数据位
    delay_us(5);            // % 延时最小要4us，保持SCL为高
    IIC_SCL = 0;            // % 拉低SCL
}


// % “从机”返回ack应答信号
// % 此信号由从机产生
BIT iic_ack_signal(void)
{
    BIT ack;
    IIC_SDA = 1;                // % 主机释放“SDA”，为读“ack”做准备
    delay_us(5);                // % SCL保持4.7us，SCL为低电平“0”
    IIC_SCL = 1;                // % 拉高SCL，读取ack
    ack = IIC_SDA;              // % 读取ack上的数据
    delay_us(5);                // % SCL保持4.7us，SCL为高“1”
    IIC_SCL = 0;                // % 释放SCL，SCL为低“0”
    return(ack);
}






// % 停止状态：当时钟线“SCL”为高电平时，数据线“SDA”出现低电平到高电平
// % 跳变时，标志IIC总线传输数据结束。由主机发出。
void iic_stop_signal(void)
{
    IIC_SCL = 0;                // % SCL为低
    IIC_SDA = 0;                // % SDA为低
    delay_us(5);                // % 稍作延时
    IIC_SCL = 1;                // % SCL为高
    delay_us(5);                // % 稍作延时
    IIC_SDA = 1;                // % SDA为高
    delay_us(5);                // % 稍作延时
}



############################################################
### % AT24C02_E2PROM <===> 器件地址
############################################################
________________________________________
D7   D6   D5   D4   D3   D2   D1   D0
A6   A5   A4   A3   A2   A1   A0   R/W
________________________________________
// % 如果一个从机有“7”位寻址位，其中“4”位是固定位，“3”位是可编程位
// % AT24C02_E2PROM: A6~A3[1010]是固定位
// % AT24C02_E2PROM: A2~A0[000]是可编程位
// % AT24C02_E2PROM: 最多可以放“8”个


// % addr = 0x50
// % 写一个字节，第一个字节是器件地址
// % 向e2prom中写入它的地址
// % 返回从机的ack状态
BIT e2prom_addr(uint8_t addr)
{
    BIT ack;
    iic_start_signal();         // % 发送起始信号
    iic_write_byte(addr<<1);    // % (0x50<<1); 0xA0
    ack = iic_ack_signal();     // % 每写一个字节，从机返回ack
    iic_stop_signal();          // % 发送结束信号
    return(ack);
}




############################################################
### % AT24C02_E2PROM <===> 读写操作
############################################################
从AT24C02_E2PROM中的“00”地址处读出数据显示在LCD1602中
再从“00”地址处的数据加“1”写回到“00”地址处。


// % 选择性读(0x00~0xFF)， 只读取一个字节 
// % AT24C02_E2PROM共有256个字节
// 1 “主机”发送起始信号
// 2 “主机”发送器件地址(A0), 从机发送(ack=0)
// 3 “主机”发送器件地址的地址(0x00), 从机发送(ack=0)
// 4 “主机”重新发送起始信号
// 5 “主机”发送器件地址(A1), 从机发送(ack=0)
// 6 “主机”接收地址(0x00)中的内容, “主机”发送(Nack=1)
// 7 “主机”发送停止信号
uint8_t eeprom_read_byte(uint8_t, icc_addr, uint8_t icc_addr_byte)
{
    uint8_t dat;
    iic_start_signal();             // % 发送起始信号
    iic_write_byte(icc_addr<<1);    // % 发送器件地址, 从机应答在内部实现
    iic_write_byte(icc_addr_byte);  // % 发送器件地址的内部存储器地址
    iic_start_signal();             // % 从新发送起始信号(重启总线)
    // % 发送器件地址, 后续操作为读操作(此时不需要器件内部存储器地址)
    iic_write_byte((icc_addr<<1) | 0x01); 
    dat = iic_read_byte();          // % 从总线读取一个字节数据
    host_send_ack(1);               // % 主机发送noACK=“1”，不读了，只读1个字节 
    iic_stop_signal();              // % 发送结束信号
    return(dat);                    // % 返回读取的内容
}


// % 向eeprom中写入“1”字节
// % 字节写(参数： 器件地址， 器件内部地址， 数据)
void eeprom_write_byte(uint8_t, icc_addr, uint8_t icc_addr_byte, uint8_t dat)
{
    uint8_t dat;
    iic_start_signal();             // % 发送起始信号
    iic_write_byte(icc_addr<<1);    // % 发送器件地址, 从机应答在内部实现
    iic_write_byte(icc_addr_byte);  // % 发送器件地址的内部存储器地址, 从机应答在内部实现
    iic_write_byte(dat);            // % 向eeprom中写入一个字节, 从机应答在内部实现
    iic_stop_signal();              // % 发送结束信号后，器件才会把数据进行擦写操作，
                                    // % 搬运到非易失区，这段时间里面器件不再响应主机的操作
}



############################################################
### % main.c 单个字节的读写操作
############################################################
// 1 从“eeprom”器件地址(0x50, 0x00)处读取一个字节并显示出来
// 2 dat = eeprom_read_byte(0x50, 0x00); 存储到“dat”中
// 3 dat++;
// 4 再从“eeprom”器件地址(0x50, 0x00)处读取一个字节并显示出来

uint8_t dat;
uint8_t str[5];
dat = eeprom_read_byte(0x50, 0x00);
lcd1602_set_position(0, 0);
lcd1602_write_data(dat/100 + '0');      // % 百位
lcd1602_write_data(dat/10%10 + '0');    // % 十位
lcd1602_write_data(dat%10 + '0');       // % 个位
num_to_str(dat, str);
lcd1602_show_str(5, 0, str);

dat++;

eeprom_write_byte(0x50, 0x00, dat);
lcd1602_set_position(0, 1);
lcd1602_write_data(dat/100 + '0');      // % 百位
lcd1602_write_data(dat/10%10 + '0');    // % 十位
lcd1602_write_data(dat%10 + '0');       // % 个位
num_to_str(dat, str);
lcd1602_show_str(5, 1, str);




############################################################
### % 进制转换
############################################################
// % 数据转“16”进制数据显示
void num_to_str(uint8_t dat, uint8_t *str)
{
    uint8_t tmp;
    tmp = dat >> 4;             // % 取高4位
    if (tmp <= 9)
        *str++ = tmp + '0';     // % <=9
     else
        *str++ = tmp + '7';     // % 或者(tmp-10+'A')
        
     tmp = dat & 0x0F;          // % 取低4位
     if (tmp <= 9)
        *str++ = tmp + '0';     // % <=9
     else
        *str++ = tmp + '7';     // % 或者(tmp-10+'A')
     // % *str++先执行后面的操作，最后再加“加”
     *str = '\0';               // % 字符串结束标志“\0”
}

















