############################################################
### % Cortex-M3 NVIC(内嵌向量中断控制器)
############################################################
0           111  ______________________，所有8位用于指定响应优先级
1           110  最高1位用于指定抢占式优先级，最低7位用于指定响应优先级
2           101  最高2位用于指定抢占式优先级，最低6位用于指定响应优先级
3           100  最高3位用于指定抢占式优先级，最低5位用于指定响应优先级
4           011  最高4位用于指定抢占式优先级，最低4位用于指定响应优先级
5           010  最高5位用于指定抢占式优先级，最低3位用于指定响应优先级
6           001  最高6位用于指定抢占式优先级，最低2位用于指定响应优先级
7           000  最高7位用于指定抢占式优先级，最低1位用于指定响应优先级  
_______________________________________________________________
% Cortex-M3允许具有较少中断源时使用较少的寄存器位指定中断源的优先级，
% 因此STM32把指定中断优先级的寄存器位减少到4位，这4个寄存器位的分组方式如下：
第0组：所有4位用于指定响应优先级
第1组：最高1位用于指定抢占式优先级，最低3位用于指定响应优先级
第2组：最高2位用于指定抢占式优先级，最低2位用于指定响应优先级
第3组：最高3位用于指定抢占式优先级，最低1位用于指定响应优先级
第4组：所有4位用于指定抢占式优先级
_______________________________________________________________
1）抢占优先级越小，优先级越高；相同抢占优先级的中断不能嵌套；

2）相同抢占优先级N个中断发生时，响应优先级越小的中断首先执行（不能嵌套），
   如果响应优先级也均相同，则根据各中断对应向量表的位置来确定，
   向量表中越靠前的中断先响应。
% SCB->AIRCR寄存器的[10:8]位bit，决定了，
% IP寄存器[4:7]bit的高四位的抢占与响应位的分配
% N    SCB->AIRC[10:8]    IPR[7:4]       分配结果
_______________________________________________________________
0           111             0:4        0位抢占优先级, 4位响应优先级
1           110             1:3        1位抢占优先级, 3位响应优先级
2           101             2:2        2位抢占优先级, 2位响应优先级
3           100             3:1        3位抢占优先级, 1位响应优先级
4           011             4:0        4位抢占优先级, 0位响应优先级   
_______________________________________________________________


% 微控制器软件接口标准<CMSIS>
% (Cortex Microcontroller Software Interface Standard) 
% 是 Cortex-M 处理器系列的与供应商无关的硬件抽象层
__I     /* defines 'read only' permissions    */定义只读允许位
__O     /* defines 'write only' permissions   */定义只写允许位
__IO    /* defines 'read / write' permissions */定义读/写允许位
 
 

############################################################
### % Cortem-M3系统异常
############################################################ 
% 系统异常优先级寄存器阵列(0xE000_ED18 - 0xE000_ED23)
_________________________________________________
0xE000_ED18     PRI_4   % 存储器管理 fault 的优先级
0xE000_ED19     PRI_5   % 总线 fault 的优先级
0xE000_ED1A     PRI_6   % 用法 fault 的优先级
0xE000_ED1B     ‐ ‐ ‐ ‐
0xE000_ED1C     ‐ ‐ ‐ ‐
0xE000_ED1D     ‐ ‐ ‐ ‐
0xE000_ED1E     ‐ ‐ ‐ ‐
0xE000_ED1F     PRI_11  % SVC 优先级
0xE000_ED20     PRI_12  % 调试监视器的优先级
0xE000_ED21     ‐ ‐ ‐ ‐
0xE000_ED22     PRI_14  % PendSV 的优先级
0xE000_ED23     PRI_15  % SysTick 的优先级
_________________________________________________



% 系统Handler控制及状态寄存器SHCSR(地址:0xE000_ED24)
_________________________________________________
[18]    USGFAULTENA(R/W)    % 用法 fault 服务例程使能位
[17]    BUSFAULTENA(R/W)    % 总线 fault 服务例程使能位
[16]    MEMFAULTENA(R/W)    % 存储器管理 fault 服务例程使能位
[15]    SVCALLPENDED(R/W)   % SVC 悬起中
[14]    BUSFAULTPENDED(R/W) % 总线 fault 悬起中,细节同上
[13]    MEMFAULTPENDED(R/W) % 存储器管理 fault 悬起中,细节同上
[12]    USGFAULTPENDED(R/W) % 用法 fault 悬起中,细节同上
[11]    SYSTICKACT(R/W)     % SysTick 异常活动中
[10]    PENDSVACT(R/W)      % PendSV 异常活动中
[9 ]    ---
[8 ]    MONITORACT(R/W)     % Monitor 异常活动中
[7 ]    SVCALLACT(R/W)      % SVC 异常活动中
6:4]    ---
[3 ]    USGFAULTACT(R/W)    % 用法 fault 异常活动中
[2 ]    ---
[1 ]    BUSFAULTACT(R/W)    % 总线 fault 异常活动中
[0 ]    MEMFAULTACT(R/W)    % 存储器管理 fault 异常活动中
_________________________________________________



% 中断控制及状态寄存器ICSR(地址:0xE000_ED04)
_________________________________________________
[31]    NMIPENDSET(R/W)     % 写 1 以悬起 NMI,因为 NMI 的优先级最高且从
                            % 不掩蔽,在置位此位后将立即进入 NMI 服务例程
[28]    PENDSVSET(R/W)      % 写 1 以悬起 PendSV
[27]    PENDSVCLR(W)        % 写 1 以清除 PendSV 悬起状态
[26]    PENDSTSET(R/W)      % 写 1 以悬起 SysTick。
[25]    PENDSTCLR(W)        % 写 1 以清除 SysTick 悬起状态
[23]    ISRPREEMPT(R)       % 为 1 时,则表示一个悬起的中断将在下一步时进
                            % 入活动状态(用于单步执行时的调试目的)
[22]    ISRPENDING(R)       % 1=当前正有外部中断被悬起(不包括 NMI)
21:12   VECTPENDING(R)      % 悬起的 ISR 的编号。如果不止一个中断悬起,则
                            % 它的值是这引动中断中,优先级最高的那一个。
[11]    RETTOBASE(R)        % 如果异常返回后将回到基级(base level),并且没有
                            % 其它异常悬起时,此位为 1。若是在线程模式下,
                            % 在某个服务例程中,有不止一级的异常处于活动
                            % 状态,或者在异常没有活动时执行了异常服务例
                            % 程(此时执行返回指令将产生 fault。此乃高危行
                            % 为,大虾也需慎用),则此位为 0
9:0     VECTACTIVE(R)       % 当前活动的ISR编号,该位段指出当前运行中的ISR
                            % 是哪个中断的(提供异常序号),包括NMI和硬
                            % fault。 如果多个异常共享一个服务例程,该例程可根据
                            % 本位段的值来判定是哪一个异常的响应导致它的执行。把
                            % 本位段的值减去16,就得到了外中断的编号,并可以用此
                            % 编号来操作外中断相关的使能/除能等寄存器


% 中断控制器类型寄存器ICTR(地址:0xE000_E004)
_________________________________________________
4:0     INTLINESUM(R)   % 中断输入的数量,以 32 为粒度,如
        0=1  至 32
        1=33 至 64
        2=65 至 96
        ...
        
        
        
############################################################
### % 中断建立全过程的演示
############################################################
1 当系统启动后,先设置优先级组寄存器。缺省情况下使用组0(7位抢占优先级,
  1位亚优先级)
2 如果需要重定位向量表,先把硬fault和NMI服务例程的入口地址写到新表项
  所在的地址中。
3 配置向量表偏移量寄存器,使之指向新的向量表(如果有重定位的话)
4 为该中断建立中断向量。因为向量表可能已经重定位了,保险起见需要先读取向量
  表偏移量寄存器的值,再根据该中断在表中的位置,计算出服务例程入口地址应写入
  的表项,再填写之。如果一直使用ROM中的向量表,则无需此步骤。
5 为该中断设置优先级。
6 使能该中断
_________________________________________________
LDR     R0,     =0xE000ED0C  ; % 应用程序中断及复位控制寄存器
LDR     R1,     =0x05FA0500  ; % 使用优先级组 5 (2/6)
STR     R1,     [R0]         ; % 设置优先级组

MOV     R4,     #8           ; % ROM中的向量表
LDR     R5,     =(NEW_VECT_TABLE+8)
LDMIA   R4!,    {R0-R1}      ; % 读取NMI和硬Fault的向量
STMIA   R5!,    {R0-R1}      ; % 拷贝它们的向量到新表中
LDR     R0,     =0xE000ED08  ; % 向量表偏移量寄存器的地址
LDR     R1,     =NEW_VECT_TABLE
STR     R1,     [R0]         ; % 把向量表重定位
LDR     R0,     =IRQ7_Handler; % 取得IRQ#7 服务例程的入口地址
LDR     R1,     =0xE000ED08  ; % 向量表偏移量寄存器的地址
LDR     R1,     [R1]
ADD     R1,     R1,#(4*(7+16));% 计算IRQ#7 服务例程的入口地址

LDR     R0,     =0xE000E400  ; % 外部中断优先级寄存器陈列的基地址
MOV     R1,     =0xC0
STRB    R1,     [R0, #7]     ; % 把IRQ#7的优先级设置为0xC0

LDR     R0,     =0xE000E1000 ; % SETEN寄存器的地址
MOV     R1,     #(1<<7)      ; % 置位 IRQ#7的使能位
STR     R1,     [R0]         ; % 使能 IRQ#7
_________________________________________________




############################################################
### % SysTick定时器
############################################################
Cortex‐M3处理器内部包含了一个简单的定时器。因为所有的CM3芯片都带有这个定时
器,软件在不同 CM3器件间的移植工作得以化简。该定时器的时钟源可以是内部时钟(FCLK,
CM3上的自由运行时钟),或者是外部时钟( CM3处理器上的STCLK信号)。不过,STCLK的
具体来源则由芯片设计者决定,因此不同产品之间的时钟频率可能会大不相同,你需要检视
芯片的器件手册来决定选择什么作为时钟源。

% SysTick控制及状态寄存器(地址:0xE000_E010)
_________________________________________________
[16]  COUNTFLAG(R)  % 如果在上次读取本寄存器后,SysTick已经数到了0, 
                    % 则该位为 1。如果读取该位,该位将自动清零
[2 ]  CLKSOURCE(R/W)% “0” 外部时钟源(STCLK)/8, “1”内核时钟(FCLK)
[1 ]  TICKINT(R/W)  % “1” SysTick倒数到0时产生SysTick异常请求
                    % “0” 数到0时无动作
[0 ]  ENABLE(R/W)   % SysTick 定时器的使能位



############################################################
### % NVIC与中断控制
############################################################
% 每个外部中断都在 NVIC 的下列寄存器中“挂号”
0 使能与除能寄存器
1 悬起与“解悬”寄存器
2 优先级寄存器
3 活动状态寄存器
% 另外,下列寄存器也对中断处理有重大影响
4 异常掩蔽寄存器(PRIMASK, FAULTMASK 以及 BASEPRI)
5 向量表偏移量寄存器
6 软件触发中断寄存器
7 优先级分组位段
_________________________________________________________________
SETENA0(0xE000_E100)    % 中断 0‐31 的使能寄存器,共 32 个使能位位[n],
                        % 中断#n 使能(异常号 16+n)
CLRENA0(0xE000_E180)    % 中断 0‐31 的除能寄存器,共 32 个除能位位[n],
                        % 中断#n 除能(异常号 16+n)    
SETPEND0(0xE000_E200)   % 中断 0‐31 的悬起寄存器,共 32 个悬起位位[n],
                        % 中断#n 悬起(异常号 16+n) 
CLRPEND0(0xE000_E280)   % 中断 0‐31 的解悬寄存器,共 32 个解悬位位[n],
                        % 中断#n 解悬(异常号 16+n)
PRI_0(0xE000_E400)      % (8 位) 外中断#0 的优先级                        
PRI_239(0xE000_E4EF)    % (8 位) 外中断#239 的优先级     
ACTIVE0(0xE000_E300)    % 中断 0‐31 的活动状态寄存器,共 32 个状态位位[n],
                        % 中断#n 活动状态(异常号 16+n)
_________________________________________________________________


                   
############################################################
### % NVIC(Nested vectored interrupt controller)
############################################################
_____________________________________________________________________
__IO uint32_t ISER[8]; /* Interrupt Set Enable Register           */
__IO uint32_t ICER[8]; /* Interrupt Clear Enable Register         */
__IO uint32_t ISPR[8]; /* Interrupt Set Pending Register          */
__IO uint32_t ICPR[8]; /* Interrupt Clear Pending Register        */
__IO uint32_t IABR[8]; /* Interrupt Active bit Register           */
__IO uint8_t  IP[240]; /* Interrupt Priority Register (8Bit wide) */
__O  uint32_t STIR;    /* Software Trigger Interrupt Register     */
_____________________________________________________________________  


                      
############################################################
### % AIRC（Application Interrupt and Reset ControlRegister）
############################################################
/* 31:16(访问钥匙密) % 任何对该寄存器的写操作,都必须同时写入“0x05FA” */
/* 10:8 (优先级分组) % 指定中断源的抢占优先级,响应优先级 */
/* % 设置Cortem-M3为( 3位抢占优先级, 1位响应优先级 ) */
_________________________________________________
SCB->AIRCR      = 0x05FA0000 | 0x00000400;  


/* % TIM5, (此定时器的中断编号为: 50) */  
NVIC->IP[50]    = 0xF0;
NVIC->ISER[1]   = 0x00020000;


/* % TIM2, (此定时器的中断编号为: 28) */  
NVIC->IP[28]    = 0xF0;
NVIC->ISER[0]   = 0x10000000;
############################################################
### % STM32外部中断编号
############################################################
[50]_TIM5           % TIM5全局中断(0x0000_0108)
[28]_TIM2           % TIM2全局中断(0x0000_00B0)


























