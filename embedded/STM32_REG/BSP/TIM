############################################################
### % STM32_TIM1_TIM8(高级控制定时器)
############################################################
% The time-base unit includes:
1 Counter register (TIMx_CNT)               % 计数器寄存器件 (TIMx_CNT)
2 Prescaler register (TIMx_PSC)             % 预分频器寄存器 (TIMx_PSC)
3 Auto-reload register (TIMx_ARR)           % 自动装载寄存器 (TIMx_ARR)
4 Repetition counter register (TIMx_RCR)    % 重复次数寄存器 (TIMx_RCR)

5 Counter overflow                          % 计数器溢出
6 Update event (UEV)                        % 更新事件
7 Update interrupt flag (UIF)               % 更新中中断标志



############################################################
### % Repetition counter (TIMx->RCR重复次数寄存器)
############################################################




############################################################
### % Clock selection(时钟选择)
############################################################
0 % Internal clock source (CK_INT) | 内部时钟源(CK_INT)
  如果禁止了从模式控制器(SMS=000),
  则(TIMx_CR1寄存器的“CEN,DIR位”)和(TIMx_EGR寄存器的“UG位”)是事实
  上的控制位,并且只能被软件修改(except UG which remains cleared 
  automatically).只要CEN位被写成’1’,预分频器的时钟就由内部时钟CK_INT
  提供。
% UG:产生更新事件(Update generation)
_____________________________
该位由软件置’1’,由硬件自动清’0’。
0:无动作;
1:重新初始化计数器,并产生一个更新事件。注意预分频器的计数器也被清’0’(但是
预分频系数不变)。 若在中心对称模式下或DIR=0(向上计数)  则计数器被清’0’;
若DIR=1(向下计数)则计数器取TIMx_ARR的值


1 % 外部时钟源模式1
当TIMx_SMCR寄存器的SMS=111时,此模式被选中。计数器可以在选定输入端的每个
上升沿或下降沿计数。


2 % 外部时钟源模式2


############################################################
### % 输入捕获模式
############################################################
% 在输入捕获模式下,当检测到ICx信号上相应的边沿后,
计数器的当前值被锁存到捕获/比较寄存器(TIMx_CCRx)中。当发生捕获事件时,
相应的CCxIF标志(TIMx_SR寄存器)被置1,如果开放了中断或者DMA操作,则将产
生中断或者DMA请求。如果发生捕获事件时CCxIF标志已经为高,  那么重复捕获
标志CCxOF(TIMx_SR寄存器)被置1。写CCxIF=0可清除CCxIF,  或读取存储
在TIMx_CCRx寄存器中的捕获数据也可清除CCxIF。写CCxOF=0可清除CCxOF。

% 以下例子说明如何在TI1输入的上升沿时捕获计数器的值到TIMx_CCR1寄存器中,步骤如下:
1 % 选择有效输入端:TIMx_CCR1必须连接到TI1输入,所以写入TIMx_CCR1寄存器中的
  CC1S=01,只要CC1S不为’00’,通道被配置为输入,并且TIMx_CCR1寄存器变为只读
2 % 根据输入信号的特点,配置输入滤波器为所需的带宽(即输入为TIx时,输入滤波器控制位是
  TIMx_CCMRx寄存器中的ICxF位)。假设输入信号在最多5个内部时钟周期的时间内抖动,
  我们须配置滤波器的带宽长于5个时钟周期;因此我们可以(以f DTS 频率)连续采样8次,以确
  认在TI1上一次真实的边沿变换,即在TIMx_CCMR1寄存器中写入"IC1F=0011"
3 % 选择TI1通道的有效转换边沿,在TIMx_CCER寄存器中写入CC1P=0(上升沿)。
4 % 配置输入预分频器。在本例中,我们希望捕获发生在每一个有效的电平转换时刻,因此预
  分频器被禁止(写TIMx_CCMR1寄存器的IC1PS=00)
5 % 设置TIMx_CCER寄存器的CC1E=1,允许捕获计数器的值到捕获寄存器中。
6 % 如果需要,通过设置TIMx_DIER寄存器中的CC1IE位允许相关中断请求,通过设置
  TIMx_DIER寄存器中的CC1DE位允许DMA请求。









############################################################
### % STM32高级定时器“1”(使用内部时钟CK_INT)(FCLK=72MHz)
############################################################
/* 开启高级定时器1的时钟 */
RCC->APB2ENR |= (uint32_t)RCC_APB2ENR_TIM1EN;


/* SMS[2:0]:从模式选择 (Slave mode selection) */
/* 000:关闭从模式 – 如果CEN=1,则预分频器直接由内部时钟驱动 */
/* TIM_SMCR_SMS=000 */
TIM1->SMCR &= (uint32_t)((uint32_t)~(TIM_SMCR_SMS));


/* 0:TIMx_ARR寄存器没有缓冲; */
TIM1->CR1 &= (uint32_t)((uint32_t)~(TIM_CR1_ARPE));


/* 0:计数器向上计数; */
TIM1->CR1 &= (uint32_t)((uint32_t)~(TIM_CR1_DIR));


/* 1:如果使能了更新中断或DMA请求,则只有计数器溢出/下溢才产生更新中断或DMA请求。*/
TIM1->CR1 |= (uint32_t)TIM_CR1_URS;


/* 清零计数器 */
TIM->CNT &= (uint32_t)((uint32_t)~(TIM_CNT_CNT));


/* 定时1秒 */
TIM->PSC = (7200-1);
TIM->ARR = (10000-1);


/* 使能高级定时器1中断 */



/* 启动高级定时器1 */
TIM1->CR1 |= (uint32_t)TIM_CR1_CEN;


















