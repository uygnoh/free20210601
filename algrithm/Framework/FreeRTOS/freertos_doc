############################################################
### % freeRTOS
############################################################
% https://doc.embedfire.com/rtos/freertos/zh/latest/index.html



############################################################
### % FreeRTOSConfig.h
############################################################
/*
配置为“1”时，RTOS使用抢占式调度器
配置为“0”时，RTOS使用协作式调度器
*/
configUSE_PREEMPTION


/*
配置为“0”时，通用方法
1 可以用于所有FreeRTOS支持的硬件。
2 完全用C实现，效率略低于特殊方法。
3 不强制要求限制最大可用优先级数量。
配置为“1”时，特定硬件方法
1 并非所有硬件都支持。
2 必须将configUSE_PORT_OPTIMISED_TASK_SELECTION设置为 1 。
3 依赖于一个或多个架构特定汇编指令（通常为计数前导零（CLZ）或等效指令）
4 比通用方法更有效率。
5 一般强制限定最大可用优先级数目为32。
*/
configUSE_PORT_OPTIMISED_TASK_SELECTION



/*
配置为“1”时，使能低功耗tickless模式
配置为“0”时，保持系统节拍（SysTick）中断一直运行
*/
configUSE_TICKLESS_IDLE


/*
配置为“1”时，使用空闲钩子（类似于回调函数）
配置为“0”时，忽略空闲钩子
*/
configUSE_IDLE_HOOK


/*
配置为“1”时，那么必须定义一个malloc()失败钩子函数
配置为“0”时，malloc()失败钩子函数不会被调用
*/
configUSE_MALLOC_FAILED_HOOK


/*
如果configUSE_TIMERS和configUSE_DAEMON_TASK_STARTUP_HOOK都设置为1，
那么应用程序必须定义一个钩子函数
*/
configUSE_DAEMON_TASK_STARTUP_HOOK


/*
配置为“1”时，使用时间片钩子（Tick Hook）
配置为“0”时，忽略时间片钩子
*/
configUSE_TICK_HOOK


/*
写入实际的CPU内核时钟频率，也就是CPU指令执行频率
*/
configCPU_CLOCK_HZ


/*
*/
configSYSTICK_CLOCK_HZ


/*
RTOS 系统自己的节拍中断的频率。
即一秒中断的次数，每次中断RTOS都会进行任务调度
*/
configTICK_RATE_HZ


/*
配置应用程序有效的优先级数目。
任何数量的任务都可以共享一个优先级，使用协程可以单独的给与它们优先权
*/
configMAX_PRIORITIES


/*
定义空闲任务使用的堆栈大小。
通常此值不应小于对应处理器演示例程文件FreeRTOSConfig.h中定义的数值
*/
configMINIMAL_STACK_SIZE


/*
调用任务函数时，需要设置描述任务信息的字符串，
这个宏用来定义该字符串的最大长度。这里定义的长度包括字符串结束符'\0'。
*/
configMAX_TASK_NAME_LEN



/*
配置为“1”时，表示启动可视化跟踪调试，会激活一些附加的结构体成员和函数
配置为“0”时，在真正发布程序时必须将其关闭，因为其对于FreeRTOS的性能是有影响的
*/
configUSE_TRACE_FACILITY
/*
设置宏configUSE_TRACE_FACILITY和configUSE_STATS_FORMATTING_FUNCTIONS为1
会编译vTaskList()和vTaskGetRunTimeStats()函数。如果将这两个宏任意一个设置为0，
上述两个函数将被忽略。通常也是在调试时才使用，用来观察各任务。
*/
configUSE_STATS_FORMATTING_FUNCTIONS


/*
配置为“1”时，会使TickType_t为无符号的16位类型定义
配置为“0”时，会使TickType_t为无符号的32位类型定义
*/
configUSE_16_BIT_TICKS


/*
配置为“1”时，其它共享空闲优先级的用户任务就绪时，空闲任务立刻让出CPU，
用户任务运行，这样确保了能最快响应用户任务
配置为“0”时，将阻止空闲任务为用户任务让出CPU，直到空闲任务的时间片结束。
这确保所有处在空闲优先级的任务分配到相同多的处理器时间，但是，这是以分配
给空闲任务更高比例的处理器时间为代价的。
*/
configIDLE_SHOULD_YIELD


/*
配置为“1”时，将会开启任务通知功能，有关的API函数也会被编译
配置为“0”时，关闭任务通知功能，相关API函数也不会被编译
*/
configUSE_TASK_NOTIFICATIONS


/*
每个RTOS任务都有一个任务通知数组
*/
configTASK_NOTIFICATION_ARRAY_ENTRIES


/*
配置为“1”时，表示使用互斥量
配置为“0”时，表示忽略互斥量
*/
configUSE_MUTEXES


/*
配置为“1”时，表示使用递归互斥量
配置为“0”时，表示不使用
*/
configUSE_RECURSIVE_MUTEXES


/*
配置为“1”时，表示使用计数信号量
配置为“0”时，表示不使用
*/
configUSE_COUNTING_SEMAPHORES


/*
配置为“1”时，表示使用“替代”队列函数
配置为“0”时，表示不使用
注：“替代”队列函数已经被弃用，在新的设计中不要使用它！
*/
configUSE_ALTERNATIVE_API


/*
配置为“1”时，
配置为“0”时，
*/
configCHECK_FOR_STACK_OVERFLOW


/*
配置为“1”时，
配置为“0”时，
*/
configQUEUE_REGISTRY_SIZE



/*
配置为“1”时，使能队列集功能（可以阻塞、挂起到多个队列和信号量）
配置为“0”时，取消队列集功能
*/
configUSE_QUEUE_SETS


/*
配置为“1”时，表示：FreeRTOS使用基于时间片的优先级抢占式调度器
配置为“0”时，
*/
configUSE_TIME_SLICING


/*
配置为“1”时，每一个创建的任务会分配一个newlib（一个嵌入式C库）reent结构
配置为“0”时，
*/
configUSE_NEWLIB_REENTRANT




/*
就是为了兼容之前的版本用的宏
*/
configENABLE_BACKWARD_COMPATIBILITY


/*
设置每个任务的线程本地存储指针数组大小
*/
configNUM_THREAD_LOCAL_STORAGE_POINTERS


/*
配置为“1”时，
配置为“0”时，
*/
configSTACK_DEPTH_TYPE


/*
配置为“1”时，
配置为“0”时，
*/
configMESSAGE_BUFFER_LENGTH_TYPE


/*
配置为“1”时，那么可以使用应用程序编写器提供的RAM创建RTOS对象
配置为“0”时，则只能使用从FreeRTOS堆分配的RAM创建RTOS对象
*/
configSUPPORT_STATIC_ALLOCATION


/*
配置为“1”时，则可以使用从FreeRTOS堆中自动分配的RAM创建RTOS对象
配置为“0”时，则只能使用应用程序编写器提供的RAM创建RTOS对象
*/
configSUPPORT_DYNAMIC_ALLOCATION


/*
FreeRTOS堆中可用的RAM总量。
该值仅在configSUPPORT_DYNAMIC_ALLOCATION设置为 1 且应用程序
使用FreeRTOS源代码下载中提供的示例内存分配方案之一时该定义才有效
*/
configTOTAL_HEAP_SIZE


/*
默认情况下，FreeRTOS堆由FreeRTOS声明，并由链接器放置在内存中。 
将configAPPLICATION_ALLOCATED_HEAP设置为1允许应用程序编写
器声明堆，这允许应用程序将堆放置在内存中的任何位置。
*/
configAPPLICATION_ALLOCATED_HEAP


/*
配置为“1”时，
配置为“0”时，
*/
configSTACK_ALLOCATION_FROM_SEPARATE_HEAP


/*
配置为“1”时，使能运行时间统计功能
配置为“0”时，
*/
configGENERATE_RUN_TIME_STATS


/*
配置为“1”时，表示使用协程
配置为“0”时，表示不使用协程
*/
configUSE_CO_ROUTINES


/*
应用程序协程（Co-routines）的有效优先级数目，
任何数目的协程都可以共享一个优先级。使用协程可以单独的分配给任务优先级
*/
configMAX_CO_ROUTINE_PRIORITIES


/*
配置为“1”时，使用软件定时器
配置为“0”时，不使用软件定时器功能
*/
configUSE_TIMERS


/*
设置软件定时器服务/守护进程的优先级
*/
configTIMER_TASK_PRIORITY


/*
设置软件定时器命令队列的长度
*/
configTIMER_QUEUE_LENGTH


/*
设置软件定时器服务/守护进程任务的堆栈深度
*/
configTIMER_TASK_STACK_DEPTH



/*
Cortex-M3硬件设备需要设置宏configKERNEL_INTERRUPT_PRIORITY；
Cortex-M硬件设备需要设置宏configMAX_SYSCALL_INTERRUPT_PRIORITY;
configMAX_SYSCALL_INTERRUPT_PRIORITY和configMAX_API_CALL_INTERRUPT_PRIORITY;
这两个宏是等价的，后者是前者的新名字，用于更新的移植层代码。
应该将configKERNEL_INTERRUPT_PRIORITY设置为最低优先级。
*/
configKERNEL_INTERRUPT_PRIORITY
configMAX_SYSCALL_INTERRUPT_PRIORITY
configMAX_API_CALL_INTERRUPT_PRIORITY


/*
configASSERT()宏的语义与标准C assert（）宏的语义相同
如果传递给configASSERT()的参数为零，则触发断言。
*/
configASSERT



/*
该值仅被FreeRTOS MPU使用。如果设置为1，那么应用程序编写器必须提供一个名为“application_defined_privileged_functions.h”的头文件，在该头文
件中可以实现应用程序writer需要在特权模式下执行的功能。*** 注意，尽管有.h扩展名，
头文件应该包含C函数的实现，而不仅仅是函数的原型(类似于ARM提供的Cortex-m的内核源文件)
*/
configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS



/*
*/  
configTOTAL_MPU_REGIONS
configTEX_S_C_B_FLASH 
configTEX_S_C_B_SRAM
configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY



/*
以“INCLUDE”起始的宏允许用户不编译那些应用程序不需要的实时内核组件（函数），
这可以确保在你的嵌入式系统中RTOS占用最少的ROM和RAM。
*/
INCLUDE Parameters






